(* ------------------------------------------------------------------------ *)

(* The type of arrays is axiomatized. *)

abstract array a
fact exclusive (array a)

(* A Mezzo array is implemented as an OCaml array. Because Mezzo arrays
   are exclusive, they include an adopter field. We use the first slot
   of the array for this purpose, so a Mezzo array of length [n] is
   represented as an OCaml array of length [n+1]. *)

(* ------------------------------------------------------------------------ *)

(* The primitive operations on arrays. *)

(* WHEN IMPLEMENTING THESE OPERATIONS, DO NOT FORGET ABOUT THE ADOPTER
   FIELD. *)

val max_length : int =
  builtin _mz_array_max_length

val length : [a] array a -> int =
  builtin _mz_array_length

val get : [a] duplicable a => (array a, int) -> a =
  builtin _mz_array_get

val set : [a] (array a, int, a) -> () =
  builtin _mz_array_set

val unsafe_get : [a] duplicable a => (array a, int) -> a =
  builtin _mz_array_unsafe_get

val unsafe_set : [a] (array a, int, a) -> () =
  builtin _mz_array_unsafe_set

val create : [a] duplicable a => (int, a) -> array a =
  builtin _mz_array_create

val unsafe_sub : [a] duplicable a => (array a, int, int) -> array a =
  builtin _mz_array_unsafe_sub

val append_prim : [a] duplicable a => (array a, array a) -> array a =
  builtin _mz_array_append_prim

(* OCaml's primitive operation [Array.concat] uses an OCaml list. We cannot
   expose it in Mezzo unless a Mezzo list is an OCaml list. This will be
   possible once we implement the keyword [slim]. *)

val unsafe_blit : [a] duplicable a => (array a, int, array a, int, int) -> () =
  builtin _mz_array_unsafe_blit

(* ------------------------------------------------------------------------ *)

(* [transform] is an in-place version of [mapi]: if applies the function [f],
   in place, to every element of the array. It can be used to perform a strong
   update over the entire array. It cannot be type-checked in Mezzo today, so
   it is a primitive operation. *)

val transform:  [a, b, p : perm] (
  consumes r: array a,
  f: (int, consumes a | p) -> b
  | p
) -> (| r @ array b) =
  builtin _mz_array_transform

(* One could imagine variants of this operation, e.g., an operation that
   performs a strong update simultaneously over TWO arrays, etc., etc.
   We cannot possibly think of all combinations. A truly general solution
   involves permissions for array segments, which allow [transform] and
   its variants to be programmed and type-checked. *)

(* ------------------------------------------------------------------------ *)

(* [init] is the composition of [create] and [transform]. *)

val init [a, p : perm] (
  n: int,
  f: (int | p) -> a
  | p)
  : array a
=
  (* Allocate an array and fill it with an arbitrary value, say 0.
     Because the type [int] is duplicable, this is well-typed! *)
  let r : array int = create (n, 0) in
  (* Transform the array. *)
  transform (r, fun (i: int, int | p) : a =
    f i
  );
  r

(* ------------------------------------------------------------------------ *)

(* [magic_get] is a version of [get] that does not carry the constraint
   [duplicable a]. It is unsound, so it must be used with care. We use it,
   below, to define a few operations which (we believe) are sound. *)

val magic_get : [a] (array a, int) -> a =
  builtin _mz_array_get

(* The following functions can be programmed using [get] and [set], but if we
   do so, we end up with a constraint [duplicable a], which is in fact
   unnecessary, because no value is duplicated in the process. Thus, we use
   [magic_get] instead of [get]. *)

val swap [a] (r: array a, i: int, j: int) : () =
  if i <> j then begin
    let ri = magic_get (r, i) in
    set (r, i, magic_get (r, j));
    set (r, j, ri)
  end

val consult [a, pre : perm, b] (
  r: array a, i: int,
  f: (a | consumes pre) -> b
  | consumes pre
) : b =
  f (magic_get (r, i))

val update [a, pre : perm, post : perm] (
  r: array a, i: int,
  f: (consumes a | consumes pre) -> (a | post)
  | consumes pre
) : (| post) =
  set(r, i, f (magic_get (r, i)))

(* [consult] is a particular use of [get], with delimited scope, that does
   not require the element type to be duplicable. The function [f] does not
   have access to the array, so using [consult] instead of [get] is a way
   of ensuring that we only read one element at a time (and give it back). *)

(* The type of [consult] advertises the fact that [consult] invokes [f]
   exactly once. Indeed, [f] is invoked at least once, otherwise [consult]
   would not be able to produce an element of type [b]. And [f] is invoked
   at most once, because [f] requires and consumes the permission [pre],
   which is not duplicable. *)

(* Analogous comments hold about [update]. *)

(* A drawback of this approach is that the user has to work in CPS style.
   Could we somehow impose the same discipline and obtain the same effect
   in direct style? We would need an abstract permission that represents
   an array with a hole at a particular index and a particular value, and
   we would need a coercion that fills the hole. I am afraid that it might
   be just as cumbersome as using [consult] or [update]! *)

(* ------------------------------------------------------------------------ *)

(* The following are safe wrappers for the unsafe primitive operations.
   They are implemented in the same manner as in OCaml. *)

val sub [a] duplicable a => (r: array a, ofs: int, len: int) : array a =
  if len < 0 || ofs > length r - len
  then fail
  else unsafe_sub (r, ofs, len)

val copy [a] duplicable a => (r: array a) : array a =
  (* OCaml's implementation contains a special case for an array
     of length 0. We cannot keep this special case, due to the
     fact that our arrays are exclusive and have an adopter field. *)
  unsafe_sub (r, 0, length r)

val append [a] duplicable a => (r1: array a, r2: array a) : array a =
  let l1 = length r1 in
  if l1 = 0 then copy r2
  else if length r2 = 0 then unsafe_sub (r1, 0, l1)
  else append_prim (r1, r2)

val blit [a] duplicable a => (r1: array a, ofs1: int, r2: array a, ofs2: int, len: int) : () =
  if len < 0 || ofs1 < 0 || ofs1 > length r1 - len
             || ofs2 < 0 || ofs2 > length r2 - len
  then fail
  else unsafe_blit (r1, ofs1, r2, ofs2, len)

(* ------------------------------------------------------------------------ *)

(* The above copying functions are restricted to arrays of duplicable
   elements. However, it also makes sense to copy an array (or an array
   segment) of non-duplicable elements, provided the original array is
   subsequently deprived of the ownership of its elements.  We provide an
   experimental function, [steal], for this purpose.  *)

(* Because we do not have permissions for an array segment, all of the
   original array elements are lost, even if only a segment of the array is
   copied. For simplicity, we force the entire array to be copied; we do not
   allow copying a segment and losing the ownership of the rest (although we
   could). *)

(* The original array itself is not lost; it becomes an array of unknown data,
   which can be re-used to store new data, if desired. *)

val total_blit [a] duplicable a => (r1: array a, r2: array a, ofs2: int) : () =
  blit (r1, 0, r2, ofs2, length r1)

val steal : [a] (consumes r1: array a, r2: array a, ofs2: int) -> (| r1 @ array unknown) =
  magic::magic blit

(* [steal] is a variant of [blit]. One could also define variants of [sub],
   [copy], [append], based on the same principle. *)

(* ------------------------------------------------------------------------ *)

(* Here is another variant of [blit], this time for the case where the
   entire destination array is written. In this case, a strong update
   is possible. *)

val surjective_blit [a] duplicable a => (r1: array a, ofs1: int, r2: array a) : () =
  blit (r1, ofs1, r2, 0, length r2)

val overwrite : [a, b] duplicable a => (r1: array a, ofs1: int, consumes r2: array b) -> (| r2 @ array a) =
  magic::magic surjective_blit

(* If [array] was known to be covariant, then we could require [array unknown]
   instead of [array b]. *)

(* ------------------------------------------------------------------------ *)

(* The above two variants of [blit] can be combined! *)

val bijective_blit [a] duplicable a => (r1: array a, r2: array a) : () =
  let l2 = length r2 in
  if length r1 <> l2
  then fail
  else blit (r1, 0, r2, 0, l2)

val transfer : [a, b] (consumes r1: array a, consumes r2: array b) -> (| r1 @ array unknown * r2 @ array a) =
  magic::magic bijective_blit

(**)

(*
Local Variables:
compile-command: "../mezzo newarray.mz"
End:
*)

