(* Arithmetic *)

abstract int
fact duplicable int

val ( * ) : (int, int) -> int
val ( - ) : (int, int) -> int
val ( / ) : (int, int) -> int
val ( + ) : (int, int) -> int

(* The physical equality check (==) defined below returns, in case of success, a
 * permission revealing that the two identifiers are equal. *)

(* TEMPORARY going even further, could we use rich_bool everywhere, i.e. view
   bool as a type abbreviation for rich_bool empty? If so, we would probably
   wish to include also a permission q for the False case. And define the
   Boolean operators to preserve permissions where possible. *)

data rich_bool (p : perm) =
  | RichTrue { | p }
  | RichFalse

val ( == ) : (x: unknown, y: unknown) -> rich_bool (x = y)

(* TEMPORARY on pourrait vouloir restreindre le test d'égalité == aux types
   exclusifs, ce qui permettrait de partager les blocs immutables sans
   contredire la sémantique officielle. C'est un peu un point de détail.
   D'un point de vue strictement pratique, ce ne serait pas une
   super idée? *)

data bool = True | False

val ( = ) : (int, int) -> bool
val ( <> ) : (int, int) -> bool
val ( < ) : (int, int) -> bool
val ( <= ) : (int, int) -> bool
val ( >= ) : (int, int) -> bool
val ( > ) : (int, int) -> bool

(* Bitwise AND *)
val ( & ) : (int, int) -> int

