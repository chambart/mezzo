(* Arithmetic *)

abstract int
fact duplicable int

val ( * ) : (int, int) -> int
val ( - ) : (int, int) -> int
val ( / ) : (int, int) -> int
val ( + ) : (int, int) -> int

(* The physical equality check (==) defined below returns, in case of success, a
 * permission revealing that the two identifiers are equal. *)

(* TEMPORARY going even further, could we use rich_bool everywhere, i.e. view
   bool as a type abbreviation for rich_bool empty empty? We would need to
   assign precise types to the Boolean operators. *)

data rich_bool (p : perm) (q: perm) =
  | RichFalse { | q }
  | RichTrue { | p }

val ( == ) : (x: unknown, y: unknown) -> rich_bool (x = y) empty
val ( != ) : (x: unknown, y: unknown) -> rich_bool empty (x = y)

(* TEMPORARY on pourrait vouloir restreindre le test d'égalité == aux types
   exclusifs, ce qui permettrait de partager les blocs immutables sans
   contredire la sémantique officielle. C'est un peu un point de détail.
   D'un point de vue strictement pratique, ce ne serait pas une
   super idée? *)

data bool = False | True

val ( = ) : (int, int) -> bool
val ( <> ) : (int, int) -> bool
val ( < ) : (int, int) -> bool
val ( <= ) : (int, int) -> bool
val ( >= ) : (int, int) -> bool
val ( > ) : (int, int) -> bool

(* Bitwise AND *)
val ( & ) : (int, int) -> int

(* Magic polymorphic print *)
val print  : [a] a -> ()
