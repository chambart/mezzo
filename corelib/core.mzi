(* Arithmetic *)

abstract int
fact duplicable int

val ( * ) : (int, int) -> int
val ( - ) : (int, int) -> int
val ( / ) : (int, int) -> int
val ( + ) : (int, int) -> int

(* The physical equality check (==) defined below returns, in case of success, a
 * permission revealing that the two identifiers are equal. The condition of an
 * if-then-else expression just has to be a data type with two branches. The
 * first branch means true, and the second branch means false. *)

data phys_equal (x : term) (y : term) =
  | Equals { | x = y }
  | NotEquals

val ( == ) : [a, b] (x: a, y: b) -> phys_equal x y

(* TEMPORARY the following rich_bool type seems more general than phys_equal;
   we could use it instead. *)
(* TEMPORARY going even further, could we use rich_bool everywhere, i.e. view
   bool as a type abbreviation for rich_bool empty? If so, we would probably
   wish to include also a permission q for the False case. And define the
   Boolean operators to preserve permissions where possible. *)

data rich_bool (p : perm) =
  | RichTrue { | p }
  | RichFalse

val ( === ) : (x: unknown, y: unknown) -> rich_bool (x = y)

(* TEMPORARY on pourrait vouloir restreindre le test d'égalité == aux types
   exclusifs, ce qui permettrait de partager les blocs immutables sans
   contredire la sémantique officielle. C'est un peu un point de détail.
   D'un point de vue strictement pratique, ce ne serait pas une
   super idée? *)

data bool = True | False

val ( = ) : (int, int) -> bool
val ( <> ) : (int, int) -> bool
val ( < ) : (int, int) -> bool
val ( <= ) : (int, int) -> bool
val ( >= ) : (int, int) -> bool
val ( > ) : (int, int) -> bool
