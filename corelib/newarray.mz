(* ------------------------------------------------------------------------ *)

(* The type of arrays is axiomatized. *)

abstract array a
fact exclusive (array a)

(* A Mezzo array is implemented as an OCaml array. Because Mezzo arrays
   are exclusive, they include an adopter field. We use the first slot
   of the array for this purpose, so a Mezzo array of length [n] is
   represented as an OCaml array of length [n+1]. *)

(* ------------------------------------------------------------------------ *)

(* The primitive operations on arrays. *)

val length : [a] array a -> int =
  builtin _mz_array_length

val get : [a] duplicable a => (array a, int) -> a =
  builtin _mz_array_get

val set : [a] (array a, int, a) -> () =
  builtin _mz_array_set

val unsafe_get : [a] duplicable a => (array a, int) -> a =
  builtin _mz_array_unsafe_get

val unsafe_set : [a] (array a, int, a) -> () =
  builtin _mz_array_unsafe_set

val create : [a] duplicable a => (int, a) -> array a =
  builtin _mz_array_create

val unsafe_sub : [a] duplicable a => (array a, int, int) -> array a =
  builtin _mz_array_unsafe_sub

val append_prim : [a] duplicable a => (array a, array a) -> array a =
  builtin _mz_array_append_prim

(* TEMPORARY OCaml's primitive operation [Array.concat] uses an OCaml
   list. We cannot expose it in Mezzo unless a Mezzo list is an OCaml
   list. This will be possible once we implement [slim]. *)

val unsafe_blit : [a] duplicable a => (array a, int, array a, int, int) -> () =
  builtin _mz_array_unsafe_blit

(* ------------------------------------------------------------------------ *)

(* [transform] is an in-place version of [mapi]: if applies the function [f],
   in place, to every element of the array. It can be used to perform a strong
   update over the entire array. It cannot be type-checked in Mezzo today, so
   it is a primitive operation. *)

val transform [a, b, p : perm] (
  consumes r: array a,
  f: (int, consumes a | p) -> b
  | p
) : (| r @ array b) =
  builtin _mz_array_transform  

(* ------------------------------------------------------------------------ *)

(* [init] is the composition of [create] and [transform]. *)

val init [a, p : perm] (
  n: int,
  f: (int | p) -> a
  | p)
  : array a
=
  (* Allocate an array and fill it with an arbitrary value, say 0.
     Because the type [int] is duplicable, this is well-typed! *)
  let r : array int = create (n, 0) in
  (* Transform the array. *)
  transform (r, fun (i: int, int | p) : a =
    f i
  );
  r

(* ------------------------------------------------------------------------ *)

(* The function [magic_get] is a version of [get] that does not carry the
   constraint [duplicable a]. It is unsound, so it must be used with care.
   We use it, below, to define a few operations which (we believe) are
   sound. *)

val magic_get : [a] (array a, int) -> a =
  builtin _mz_array_get

(* The function [swap] can be programmed using [get] and [set], but if we
   do so, we end up with a constraint [duplicable a], which is in fact
   superfluous, because no value is duplicated in the process. Thus, we
   use [magic_get] instead of [get]. *)

val swap [a] (r: array a, i: int, j: int) : () =
  if i <> j then begin
    let ri = magic_get (r, i) in
    set (r, i, magic_get (r, j));
    set (r, j, ri)
  end

(* The function [consult] can be programmed using [get], but if we do so, we
   end up with a constraint [duplicable a], which is in fact superfluous,
   because [f] must surrender the permission for its argument. Thus, we use
   [magic_get] instead of [get]. *)

val consult [a, pre : perm, b] (
  r: array a, i: int,
  f: (a | consumes pre) -> b
  | consumes pre
) : b =
  f(magic_get(r, i))

(* BUG
val bug (n : int) : () =
  let r : array () = create [()] (n, ()) in
  ()

I get:
  Fatal error: exception Failure("The parser shouldn't allow this")
*)

(* ------------------------------------------------------------------------ *)

(*
Local Variables:
compile-command: "../mezzo array.mz"
End:
*)
