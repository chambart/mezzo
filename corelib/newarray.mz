(* ------------------------------------------------------------------------ *)

(* The type of arrays is axiomatized. *)

abstract array a
fact exclusive (array a)

(* A Mezzo array is implemented as an OCaml array. Because Mezzo arrays
   are exclusive, they include an adopter field. We use the first slot
   of the array for this purpose, so a Mezzo array of length [n] is
   represented as an OCaml array of length [n+1]. *)

(* ------------------------------------------------------------------------ *)

(* The primitive operations on arrays. *)

(* WHEN IMPLEMENTING THESE OPERATIONS, DO NOT FORGET ABOUT THE ADOPTER
   FIELD. *)

val max_length : int =
  builtin _mz_array_max_length

val length : [a] array a -> int =
  builtin _mz_array_length

val get : [a] duplicable a => (array a, int) -> a =
  builtin _mz_array_get

val set : [a] (array a, int, a) -> () =
  builtin _mz_array_set

val unsafe_get : [a] duplicable a => (array a, int) -> a =
  builtin _mz_array_unsafe_get

val unsafe_set : [a] (array a, int, a) -> () =
  builtin _mz_array_unsafe_set

val create : [a] duplicable a => (int, a) -> array a =
  builtin _mz_array_create

val unsafe_sub : [a] duplicable a => (array a, int, int) -> array a =
  builtin _mz_array_unsafe_sub

val append_prim : [a] duplicable a => (array a, array a) -> array a =
  builtin _mz_array_append_prim

(* TEMPORARY OCaml's primitive operation [Array.concat] uses an OCaml
   list. We cannot expose it in Mezzo unless a Mezzo list is an OCaml
   list. This will be possible once we implement [slim]. *)

val unsafe_blit : [a] duplicable a => (array a, int, array a, int, int) -> () =
  builtin _mz_array_unsafe_blit

(* ------------------------------------------------------------------------ *)

(* [transform] is an in-place version of [mapi]: if applies the function [f],
   in place, to every element of the array. It can be used to perform a strong
   update over the entire array. It cannot be type-checked in Mezzo today, so
   it is a primitive operation. *)

val transform:  [a, b, p : perm] (
  consumes r: array a,
  f: (int, consumes a | p) -> b
  | p
) -> (| r @ array b) =
  builtin _mz_array_transform  

(* ------------------------------------------------------------------------ *)

(* [init] is the composition of [create] and [transform]. *)

val init [a, p : perm] (
  n: int,
  f: (int | p) -> a
  | p)
  : array a
=
  (* Allocate an array and fill it with an arbitrary value, say 0.
     Because the type [int] is duplicable, this is well-typed! *)
  let r : array int = create (n, 0) in
  (* Transform the array. *)
  transform (r, fun (i: int, int | p) : a =
    f i
  );
  r

(* ------------------------------------------------------------------------ *)

(* [magic_get] is a version of [get] that does not carry the constraint
   [duplicable a]. It is unsound, so it must be used with care. We use it,
   below, to define a few operations which (we believe) are sound. *)

val magic_get : [a] (array a, int) -> a =
  builtin _mz_array_get

(* The following functions can be programmed using [get] and [set], but if we
   do so, we end up with a constraint [duplicable a], which is in fact
   unnecessary, because no value is duplicated in the process. Thus, we use
   [magic_get] instead of [get]. *)

val swap [a] (r: array a, i: int, j: int) : () =
  if i <> j then begin
    let ri = magic_get (r, i) in
    set (r, i, magic_get (r, j));
    set (r, j, ri)
  end

val consult [a, pre : perm, b] (
  r: array a, i: int,
  f: (a | consumes pre) -> b
  | consumes pre
) : b =
  f (magic_get (r, i))

val update [a, pre : perm, post : perm] (
  r: array a, i: int,
  f: (consumes a | consumes pre) -> (a | post)
  | consumes pre
) : (| post) =
  set(r, i, f (magic_get (r, i)))

(* ------------------------------------------------------------------------ *)

(* The following are safe wrappers for the unsafe primitive operations.
   They are implemented in the same manner as in OCaml. *)

(*
val sub [a] duplicable a => (r: array a, ofs: int, len: int) : array a =
  if len < 0 || ofs > length r - len then
    fail
  else begin
    assert r @ array a; (* BUG? this fails *)
    unsafe_sub (r, ofs, len)
  end
*)

(*
val append : [a] duplicable a => (array a, array a)   -> array a
val concat : [a] duplicable a => list::list (array a) -> array a
val blit   : [a] duplicable a => (a1: array a, ofs1: int, a2: array a, ofs2: int, len: int) -> ()
*)

(*
Local Variables:
compile-command: "../mezzo newarray.mz"
End:
*)
