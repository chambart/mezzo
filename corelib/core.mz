(* Arithmetic *)

abstract int
fact duplicable int

val ( + ) : (int, int) -> int = builtin _mz_iadd
val ( - ) : (int, int) -> int = builtin _mz_isub
val ( * ) : (int, int) -> int = builtin _mz_imul
val ( / ) : (int, int) -> int = builtin _mz_idiv

(* The physical equality check (==) defined below returns, in case of success, a
 * permission revealing that the two identifiers are equal. *)

val ( == ) : (x: unknown, y: unknown) -> rich_bool (x = y) empty =
  builtin _mz_address_eq

val ( != ) (x: unknown, y: unknown) : rich_bool empty (x = y) =
  rich_not (x == y)

(* TEMPORARY on pourrait vouloir restreindre le test d'égalité == aux types
   exclusifs, ce qui permettrait de partager les blocs immutables sans
   contredire la sémantique officielle. C'est un peu un point de détail.
   D'un point de vue strictement pratique, ce ne serait pas une
   super idée? *)

val ( = )  : (int, int) -> bool = builtin _mz_ieq
val ( <> ) : (int, int) -> bool = builtin _mz_ine
val ( < )  : (int, int) -> bool = builtin _mz_ilt
val ( <= ) : (int, int) -> bool = builtin _mz_ile
val ( > )  : (int, int) -> bool = builtin _mz_igt
val ( >= ) : (int, int) -> bool = builtin _mz_ige

val max (x: int, y: int) : int =
  if x <= y then y else x

val min (x: int, y: int) : int =
  if x <= y then x else y

(* Bitwise AND *)
val ( & )  : (int, int) -> int  = builtin _mz_iand

(* Magic polymorphic print *)
val print  : [a] a -> () = builtin _mz_print_value
