<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>/home/jonathan/Code/mezzo/src/tests/in_place_traversal.hml.html</title>
<meta name="Generator" content="Vim/7.3">
<meta name="plugin-version" content="vim7.3_v10">
<meta name="syntax" content="ocaml">
<meta name="settings" content="number_lines,use_css,expand_tabs">
<style type="text/css">
<!--
pre { font-family: monospace; color: #f6f3e8; background-color: #242424; }
body { font-family: monospace; color: #f6f3e8; background-color: #242424; }
.lnr { color: #857b6f; background-color: #000000; }
.Error { color: #ffffff; background-color: #ff0000; }
.Constant { color: #e5786d; }
.Keyword { color: #8ac6f2; }
.Comment { color: #99968b; font-style: italic; }
-->
</style>
</head>
<body>
<pre>
<span class="lnr"> 1 </span><span class="Comment">(* In-place traversal of a tree, after Sobel and Friedman (1998). *)</span>
<span class="lnr"> 2 </span>
<span class="lnr"> 3 </span><span class="Comment">(* If we wish to publish this example, we must cite Walker and Morrisett,</span>
<span class="lnr"> 4 </span><span class="Comment">   ``Alias Types for Recursive Data Structures'', who do this already. *)</span>
<span class="lnr"> 5 </span>
<span class="lnr"> 6 </span><span class="Comment">(* We declare the type of trees as [exclusive] because we need trees</span>
<span class="lnr"> 7 </span><span class="Comment">   to be affine (that is, there must be no sharing) and we will</span>
<span class="lnr"> 8 </span><span class="Comment">   temporarily mutate them while we traverse them. *)</span>
<span class="lnr"> 9 </span>
<span class="lnr">10 </span><span class="Comment">(* We do not include any data in the tree, because this is an</span>
<span class="lnr">11 </span><span class="Comment">   orthogonal concern. *)</span>
<span class="lnr">12 </span>
<span class="lnr">13 </span><span class="Keyword">mutable</span> data tree <span class="Keyword">=</span>
<span class="lnr">14 </span>  <span class="Keyword">|</span> <span class="Constant">TEmpty</span>
<span class="lnr">15 </span>  <span class="Keyword">|</span> <span class="Constant">TNode</span> <span class="Keyword">{</span> left: tree<span class="Keyword">;</span> right: tree <span class="Keyword">}</span>
<span class="lnr">16 </span>
<span class="lnr">17 </span><span class="Comment">(* The continuations used by the tree traversal procedure below.</span>
<span class="lnr">18 </span><span class="Comment">   These continuations can be thought of as contexts or zippers. *)</span>
<span class="lnr">19 </span>
<span class="lnr">20 </span><span class="Keyword">mutable</span> data continuation <span class="Keyword">=</span>
<span class="lnr">21 </span>  <span class="Keyword">|</span> <span class="Constant">KInitial</span>
<span class="lnr">22 </span>  <span class="Keyword">|</span> <span class="Constant">KLeft</span> <span class="Keyword">{</span> father: continuation<span class="Keyword">;</span> right: tree <span class="Keyword">}</span>
<span class="lnr">23 </span>  <span class="Keyword">|</span> <span class="Constant">KRight</span> <span class="Keyword">{</span> left: tree<span class="Keyword">;</span> father: continuation <span class="Keyword">}</span>
<span class="lnr">24 </span>
<span class="lnr">25 </span><span class="Comment">(* Tree traversal. *)</span>
<span class="lnr">26 </span>
<span class="lnr">27 </span><span class="Comment">(* This procedure does nothing, but traverses the tree. One could adapt</span>
<span class="lnr">28 </span><span class="Comment">   it to actually do something at every node. *)</span>
<span class="lnr">29 </span>
<span class="lnr">30 </span><span class="Comment">(* Even though this procedure traverses a tree, it is tail-recursive.</span>
<span class="lnr">31 </span><span class="Comment">   The stack is encoded in the tree via link inversion. No memory</span>
<span class="lnr">32 </span><span class="Comment">   allocation is performed. *)</span>
<span class="lnr">33 </span>
<span class="lnr">34 </span><span class="Keyword">val</span> <span class="Keyword">rec</span> traverse <span class="Keyword">(</span>consumes t: tree, consumes k: continuation<span class="Keyword">)</span>: <span class="Keyword">(</span>u: tree<span class="Keyword">)</span> <span class="Keyword">=</span>
<span class="lnr">35 </span>  <span class="Comment">(* t: tree, k: continuation *)</span>
<span class="lnr">36 </span>  <span class="Keyword">match</span> explain t <span class="Keyword">with</span>
<span class="lnr">37 </span>  <span class="Keyword">|</span> <span class="Constant">TEmpty</span> <span class="Keyword">-&gt;</span>
<span class="lnr">38 </span>      continue <span class="Keyword">(</span>k, t<span class="Keyword">)</span>
<span class="lnr">39 </span>  <span class="Keyword">|</span> <span class="Constant">TNode</span> <span class="Keyword">{</span> left<span class="Keyword">;</span> right <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr">40 </span>      <span class="Comment">(* t: TNode { left = left, right = right }, left, right: tree, k: continuation *)</span>
<span class="lnr">41 </span>      <span class="Comment">(* New syntax for mutating the tag and the fields at once: conflict in the</span>
<span class="lnr">42 </span><span class="Comment">       * grammar. *)</span>
<span class="lnr">43 </span>      <span class="Comment">(* t &lt;- KLeft { father = k; right = right }; *)</span>
<span class="lnr">44 </span>      tag <span class="Keyword">of</span> t <span class="Keyword">&lt;-</span> <span class="Constant">KLeft</span><span class="Keyword">;</span>
<span class="lnr">45 </span>      t.father <span class="Keyword">&lt;-</span> k<span class="Keyword">;</span>
<span class="lnr">46 </span>      t.right <span class="Keyword">&lt;-</span> right<span class="Keyword">;</span>
<span class="lnr">47 </span>      <span class="Comment">(* t: KLeft { father = k, right = right }, left, right: tree, k: continuation *)</span>
<span class="lnr">48 </span>      <span class="Comment">(* t: continuation, left: tree *)</span>
<span class="lnr">49 </span>      traverse <span class="Keyword">(</span>left, t<span class="Keyword">)</span>
<span class="lnr">50 </span>  <span class="Error">end</span>
<span class="lnr">51 </span>
<span class="lnr">52 </span><span class="Keyword">and</span> continue <span class="Keyword">(</span>consumes k: continuation, consumes t: tree<span class="Keyword">)</span>: <span class="Keyword">(</span>u: tree<span class="Keyword">)</span> <span class="Keyword">=</span>
<span class="lnr">53 </span>  <span class="Comment">(* k: continuation, t: tree *)</span>
<span class="lnr">54 </span>  <span class="Keyword">match</span> k <span class="Keyword">with</span>
<span class="lnr">55 </span>  <span class="Keyword">|</span> <span class="Constant">KInitial</span> <span class="Keyword">-&gt;</span>
<span class="lnr">56 </span>      <span class="Comment">(* t: tree *)</span>
<span class="lnr">57 </span>      t
<span class="lnr">58 </span>  <span class="Keyword">|</span> <span class="Constant">KLeft</span> <span class="Keyword">{</span> father<span class="Keyword">;</span> right <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr">59 </span>      <span class="Comment">(* k: KLeft { father = father; right = right }, father: continuation, right: tree, t: tree *)</span>
<span class="lnr">60 </span>      <span class="Comment">(* k &lt;- KRight { left = t; father = father }; *)</span>
<span class="lnr">61 </span>      tag <span class="Keyword">of</span> k <span class="Keyword">&lt;-</span> <span class="Constant">KRight</span><span class="Keyword">;</span>
<span class="lnr">62 </span>      k.left <span class="Keyword">&lt;-</span> t<span class="Keyword">;</span>
<span class="lnr">63 </span>      k.father <span class="Keyword">&lt;-</span> father<span class="Keyword">;</span>
<span class="lnr">64 </span>      <span class="Comment">(* k: KRight { left = t; father = father }, father: continuation, right: tree, t: tree *)</span>
<span class="lnr">65 </span>      <span class="Comment">(* k: continuation, right: tree *)</span>
<span class="lnr">66 </span>      traverse <span class="Keyword">(</span>right, k<span class="Keyword">)</span>
<span class="lnr">67 </span>  <span class="Keyword">|</span> <span class="Constant">KRight</span> <span class="Keyword">{</span> left<span class="Keyword">;</span> father <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr">68 </span>      <span class="Comment">(* k: KRight { left = left; father = father }, left: tree, father: continuation, t: tree *)</span>
<span class="lnr">69 </span>      <span class="Comment">(* k &lt;- TNode { left = left; right = t }; *)</span>
<span class="lnr">70 </span>      tag <span class="Keyword">of</span> k <span class="Keyword">&lt;-</span> <span class="Constant">TNode</span><span class="Keyword">;</span>
<span class="lnr">71 </span>      k.left <span class="Keyword">&lt;-</span> left<span class="Keyword">;</span>
<span class="lnr">72 </span>      k.right <span class="Keyword">&lt;-</span> t<span class="Keyword">;</span>
<span class="lnr">73 </span>      <span class="Comment">(* k: TNode { left = left; right = t }, left: tree, father: continuation, t: tree *)</span>
<span class="lnr">74 </span>      <span class="Comment">(* k: tree, father: continuation *)</span>
<span class="lnr">75 </span>      continue <span class="Keyword">(</span>father, k<span class="Keyword">)</span>
<span class="lnr">76 </span>  <span class="Error">end</span>
<span class="lnr">77 </span>
<span class="lnr">78 </span><span class="Comment">(* The procedure [traverse] above is pretty simple and elegant, but has the</span>
<span class="lnr">79 </span><span class="Comment">   drawback that the call [traverse (t, new KInitial {})] returns a new tree,</span>
<span class="lnr">80 </span><span class="Comment">   instead of the original tree. The quick-and-dirty way of fixing this problem</span>
<span class="lnr">81 </span><span class="Comment">   is to add one dynamic check at the end, as follows. *)</span>
<span class="lnr">82 </span>
<span class="lnr">83 </span><span class="Keyword">val</span> traverse <span class="Keyword">(</span>t: tree<span class="Keyword">)</span>: <span class="Constant">()</span> <span class="Keyword">=</span>
<span class="lnr">84 </span>  <span class="Comment">(* t: tree *)</span>
<span class="lnr">85 </span>  <span class="Comment">(* Call the above version of [traverse] with an initial continuation. *)</span>
<span class="lnr">86 </span>  <span class="Keyword">let</span> u <span class="Keyword">=</span> traverse <span class="Keyword">(</span>t, <span class="Constant">KInitial</span><span class="Keyword">)</span> <span class="Keyword">in</span>
<span class="lnr">87 </span>  <span class="Comment">(* u: tree *)</span>
<span class="lnr">88 </span>  <span class="Comment">(* We now have a permission for [u], and have lost the permission for</span>
<span class="lnr">89 </span><span class="Comment">     [t]. Fortunately, the two trees should be equal: the link inversion</span>
<span class="lnr">90 </span><span class="Comment">     process, in the end, reconstructs the original tree. *)</span>
<span class="lnr">91 </span>  <span class="Keyword">if</span> explain <span class="Keyword">(</span>t <span class="Keyword">==</span> u<span class="Keyword">)</span> <span class="Keyword">then</span>
<span class="lnr">92 </span>    <span class="Comment">(* We are done. *)</span>
<span class="lnr">93 </span>    <span class="Comment">(* t: tree *)</span>
<span class="lnr">94 </span>    <span class="Constant">()</span>
<span class="lnr">95 </span>  <span class="Keyword">else</span>
<span class="lnr">96 </span>    <span class="Comment">(* Oops! *)</span>
<span class="lnr">97 </span>    fail
</pre>
</body>
</html>
