<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>/home/jonathan/Code/mezzo/src/stdlib/bucket.mz.html</title>
<meta name="Generator" content="Vim/7.3">
<meta name="plugin-version" content="vim7.3_v10">
<meta name="syntax" content="mezzo">
<meta name="settings" content="number_lines,use_css,expand_tabs">
<style type="text/css">
<!--
pre { font-family: monospace; color: #f6f3e8; background-color: #242424; }
body { font-family: monospace; color: #f6f3e8; background-color: #242424; }
.lnr { color: #857b6f; background-color: #000000; }
.Number { color: #e5786d; }
.Type { color: #cae682; }
.Constant { color: #e5786d; }
.Keyword { color: #8ac6f2; }
.Comment { color: #99968b; font-style: italic; }
-->
</style>
</head>
<body>
<pre>
<span class="lnr">  1 </span><span class="Comment">(* This module is used by the [hashtable] module, but could also be useful</span>
<span class="lnr">  2 </span><span class="Comment">   per se. It offers mutable lists of key-value pairs. *)</span>
<span class="lnr">  3 </span>
<span class="lnr">  4 </span><span class="Comment">(* -------------------------------------------------------------------------- *)</span>
<span class="lnr">  5 </span>
<span class="lnr">  6 </span><span class="Comment">(* A bucket is a mutable list of entries. Each entry holds a key and a value. *)</span>
<span class="lnr">  7 </span>
<span class="lnr">  8 </span><span class="Keyword">mutable</span> <span class="Keyword">data</span> bucket k a <span class="Keyword">=</span>
<span class="lnr">  9 </span>  <span class="Keyword">|</span> <span class="Constant">BNil</span>
<span class="lnr"> 10 </span>  <span class="Keyword">|</span> <span class="Constant">BCons</span> <span class="Keyword">{</span> key: k<span class="Keyword">;</span> value: a<span class="Keyword">;</span> tail: bucket k a <span class="Keyword">}</span>
<span class="lnr"> 11 </span>
<span class="lnr"> 12 </span><span class="Comment">(* -------------------------------------------------------------------------- *)</span>
<span class="lnr"> 13 </span>
<span class="lnr"> 14 </span><span class="Comment">(* Search. *)</span>
<span class="lnr"> 15 </span>
<span class="lnr"> 16 </span><span class="Keyword">val</span> <span class="Keyword">rec</span> mem <span class="Keyword">[</span>k, a<span class="Keyword">]</span> <span class="Keyword">(</span>
<span class="lnr"> 17 </span>  equal: <span class="Keyword">(</span>k, k<span class="Keyword">)</span> <span class="Keyword">-&gt;</span> <span class="Type">bool</span>,
<span class="lnr"> 18 </span>  x: k,
<span class="lnr"> 19 </span>  b: bucket k a
<span class="lnr"> 20 </span><span class="Keyword">)</span> : <span class="Type">bool</span> <span class="Keyword">=</span>
<span class="lnr"> 21 </span>  <span class="Keyword">match</span> b <span class="Keyword">with</span>
<span class="lnr"> 22 </span>  <span class="Keyword">|</span> <span class="Constant">BNil</span> <span class="Keyword">-&gt;</span>
<span class="lnr"> 23 </span>      <span class="Constant">false</span>
<span class="lnr"> 24 </span>  <span class="Keyword">|</span> <span class="Constant">BCons</span> <span class="Keyword">{</span> key<span class="Keyword">;</span> tail <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr"> 25 </span>      <span class="Comment">(* TEMPORARY could use || *)</span>
<span class="lnr"> 26 </span>      <span class="Keyword">if</span> equal <span class="Keyword">(</span>x, key<span class="Keyword">)</span> <span class="Keyword">then</span> <span class="Constant">true</span> <span class="Keyword">else</span> mem <span class="Keyword">(</span>equal, x, tail<span class="Keyword">)</span>
<span class="lnr"> 27 </span>  <span class="Keyword">end</span>
<span class="lnr"> 28 </span>
<span class="lnr"> 29 </span><span class="Keyword">val</span> <span class="Keyword">rec</span> assoc <span class="Keyword">[</span>k, a, p : <span class="Keyword">perm]</span> <span class="Keyword">duplicable</span> a <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Keyword">(</span>
<span class="lnr"> 30 </span>  equal: <span class="Keyword">(</span>k, k <span class="Keyword">|</span> p<span class="Keyword">)</span> <span class="Keyword">-&gt;</span> <span class="Type">bool</span>,
<span class="lnr"> 31 </span>  x: k,
<span class="lnr"> 32 </span>  b: bucket k a
<span class="lnr"> 33 </span>  <span class="Keyword">|</span> p
<span class="lnr"> 34 </span><span class="Keyword">)</span> : <span class="Type">option</span> a <span class="Keyword">=</span>
<span class="lnr"> 35 </span>  <span class="Keyword">match</span> b <span class="Keyword">with</span>
<span class="lnr"> 36 </span>  <span class="Keyword">|</span> <span class="Constant">BNil</span> <span class="Keyword">-&gt;</span>
<span class="lnr"> 37 </span>      none
<span class="lnr"> 38 </span>  <span class="Keyword">|</span> <span class="Constant">BCons</span> <span class="Keyword">{</span> key<span class="Keyword">;</span> value<span class="Keyword">;</span> tail <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr"> 39 </span>      <span class="Keyword">if</span> equal <span class="Keyword">(</span>x, key<span class="Keyword">)</span> <span class="Keyword">then</span> some value <span class="Keyword">else</span> assoc <span class="Keyword">(</span>equal, x, tail<span class="Keyword">)</span>
<span class="lnr"> 40 </span>  <span class="Keyword">end</span>
<span class="lnr"> 41 </span>
<span class="lnr"> 42 </span><span class="Keyword">val</span> <span class="Keyword">rec</span> assoc_all <span class="Keyword">[</span>k, a, p : <span class="Keyword">perm]</span> <span class="Keyword">duplicable</span> a <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Keyword">(</span>
<span class="lnr"> 43 </span>  equal: <span class="Keyword">(</span>k, k <span class="Keyword">|</span> p<span class="Keyword">)</span> <span class="Keyword">-&gt;</span> <span class="Type">bool</span>,
<span class="lnr"> 44 </span>  x: k,
<span class="lnr"> 45 </span>  b: bucket k a
<span class="lnr"> 46 </span>  <span class="Keyword">|</span> p
<span class="lnr"> 47 </span><span class="Keyword">)</span> : <span class="Type">list</span><span class="Keyword">::</span><span class="Type">list</span> a <span class="Keyword">=</span>
<span class="lnr"> 48 </span>  <span class="Keyword">match</span> b <span class="Keyword">with</span>
<span class="lnr"> 49 </span>  <span class="Keyword">|</span> <span class="Constant">BNil</span> <span class="Keyword">-&gt;</span>
<span class="lnr"> 50 </span>      <span class="Type">list</span><span class="Keyword">::</span>nil
<span class="lnr"> 51 </span>  <span class="Keyword">|</span> <span class="Constant">BCons</span> <span class="Keyword">{</span> key<span class="Keyword">;</span> value<span class="Keyword">;</span> tail <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr"> 52 </span>      <span class="Keyword">if</span> equal <span class="Keyword">(</span>x, key<span class="Keyword">)</span> <span class="Keyword">then</span> <span class="Type">list</span><span class="Keyword">::</span>cons <span class="Keyword">(</span>value, assoc_all <span class="Keyword">(</span>equal, x, tail<span class="Keyword">))</span> <span class="Keyword">else</span> assoc_all <span class="Keyword">(</span>equal, x, tail<span class="Keyword">)</span>
<span class="lnr"> 53 </span>  <span class="Keyword">end</span>
<span class="lnr"> 54 </span>
<span class="lnr"> 55 </span><span class="Comment">(* -------------------------------------------------------------------------- *)</span>
<span class="lnr"> 56 </span>
<span class="lnr"> 57 </span><span class="Comment">(* Removal of a cell. *)</span>
<span class="lnr"> 58 </span>
<span class="lnr"> 59 </span><span class="Comment">(* [remove (b, ok)] looks for the first cell whose key satisfies the predicate</span>
<span class="lnr"> 60 </span><span class="Comment">   [ok] and (if it finds one) removes it. It returns a pair of the new list</span>
<span class="lnr"> 61 </span><span class="Comment">   head and the value that was found, if one was found. *)</span>
<span class="lnr"> 62 </span>
<span class="lnr"> 63 </span><span class="Keyword">val</span> remove <span class="Keyword">[</span>k, a, p : <span class="Keyword">perm]</span> <span class="Keyword">(</span>
<span class="lnr"> 64 </span>  <span class="Keyword">consumes</span> b: bucket k a,
<span class="lnr"> 65 </span>  ok: <span class="Keyword">(</span>k <span class="Keyword">|</span> p<span class="Keyword">)</span> <span class="Keyword">-&gt;</span> <span class="Type">bool</span>
<span class="lnr"> 66 </span>  <span class="Keyword">|</span> p
<span class="lnr"> 67 </span><span class="Keyword">)</span> : <span class="Keyword">(</span>bucket k a, <span class="Type">option</span> a<span class="Keyword">)</span> <span class="Keyword">=</span>
<span class="lnr"> 68 </span>
<span class="lnr"> 69 </span>  <span class="Comment">(* Write a loop that works over two consecutive cells. We work under the</span>
<span class="lnr"> 70 </span><span class="Comment">     assumption that [prev] does not satisfy [ok], so it remains the list</span>
<span class="lnr"> 71 </span><span class="Comment">     head after the removal. The loop returns the value that was found, if</span>
<span class="lnr"> 72 </span><span class="Comment">     one was found. *)</span>
<span class="lnr"> 73 </span>  <span class="Keyword">let</span> <span class="Keyword">rec</span> loop <span class="Keyword">(</span>
<span class="lnr"> 74 </span>    <span class="Keyword">consumes</span> prev: <span class="Constant">BCons</span> <span class="Keyword">{</span> key: k<span class="Keyword">;</span> value: a<span class="Keyword">;</span> tail <span class="Keyword">=</span> this <span class="Keyword">}</span>,
<span class="lnr"> 75 </span>    <span class="Keyword">consumes</span> this: bucket k a
<span class="lnr"> 76 </span>  <span class="Keyword">|</span> p<span class="Keyword">)</span> : <span class="Keyword">(</span><span class="Type">option</span> a <span class="Keyword">|</span> prev @ bucket k a<span class="Keyword">)</span> <span class="Keyword">=</span>
<span class="lnr"> 77 </span>    <span class="Keyword">match</span> this <span class="Keyword">with</span>
<span class="lnr"> 78 </span>    <span class="Keyword">|</span> <span class="Constant">BNil</span> <span class="Keyword">-&gt;</span>
<span class="lnr"> 79 </span>        none
<span class="lnr"> 80 </span>    <span class="Keyword">|</span> <span class="Constant">BCons</span> <span class="Keyword">{</span> key<span class="Keyword">;</span> value <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr"> 81 </span>        <span class="Keyword">if</span> ok key <span class="Keyword">then</span> <span class="Keyword">begin</span>
<span class="lnr"> 82 </span>          prev.tail <span class="Keyword">&lt;-</span> this.tail<span class="Keyword">;</span>
<span class="lnr"> 83 </span>          some value
<span class="lnr"> 84 </span>        <span class="Keyword">end</span>
<span class="lnr"> 85 </span>        <span class="Keyword">else</span>
<span class="lnr"> 86 </span>          loop <span class="Keyword">(</span>this, this.tail<span class="Keyword">)</span>
<span class="lnr"> 87 </span>    <span class="Keyword">end</span>
<span class="lnr"> 88 </span>  <span class="Keyword">in</span>
<span class="lnr"> 89 </span>
<span class="lnr"> 90 </span>  <span class="Keyword">match</span> b <span class="Keyword">with</span>
<span class="lnr"> 91 </span>  <span class="Keyword">|</span> <span class="Constant">BNil</span> <span class="Keyword">-&gt;</span>
<span class="lnr"> 92 </span>      <span class="Comment">(* If the list is empty, return it. *)</span>
<span class="lnr"> 93 </span>      b, none
<span class="lnr"> 94 </span>  <span class="Keyword">|</span> <span class="Constant">BCons</span> <span class="Keyword">{</span> key<span class="Keyword">;</span> value <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr"> 95 </span>      <span class="Keyword">if</span> ok key <span class="Keyword">then</span>
<span class="lnr"> 96 </span>        <span class="Comment">(* If the first cell matches, return the list tail. *)</span>
<span class="lnr"> 97 </span>        b.tail, some value
<span class="lnr"> 98 </span>      <span class="Keyword">else</span>
<span class="lnr"> 99 </span>        <span class="Comment">(* Otherwise, enter the above loop, and return the list head. *)</span>
<span class="lnr">100 </span>        b, loop <span class="Keyword">(</span>b, b.tail<span class="Keyword">)</span>
<span class="lnr">101 </span>  <span class="Keyword">end</span>
<span class="lnr">102 </span>
<span class="lnr">103 </span><span class="Comment">(* -------------------------------------------------------------------------- *)</span>
<span class="lnr">104 </span>
<span class="lnr">105 </span><span class="Comment">(* The following two functions serve in the definition of [update] below. *)</span>
<span class="lnr">106 </span>
<span class="lnr">107 </span><span class="Comment">(* Optional insertion. *)</span>
<span class="lnr">108 </span>
<span class="lnr">109 </span><span class="Keyword">val</span> insert <span class="Keyword">[</span>k, a<span class="Keyword">]</span> <span class="Keyword">(</span>
<span class="lnr">110 </span>  <span class="Keyword">consumes</span> x: k,
<span class="lnr">111 </span>  <span class="Keyword">consumes</span> ov: <span class="Type">option</span> a,
<span class="lnr">112 </span>  <span class="Keyword">consumes</span> b: bucket k a
<span class="lnr">113 </span><span class="Keyword">)</span> : bucket k a <span class="Keyword">=</span>
<span class="lnr">114 </span>  <span class="Comment">(* There is a merge warning here; this is because we're actually merging [ov]</span>
<span class="lnr">115 </span><span class="Comment">   * into [option unknown]. Indeed, we first perform a subtraction (when the</span>
<span class="lnr">116 </span><span class="Comment">   * context provides a type annotation), and then we try to merge the remaining</span>
<span class="lnr">117 </span><span class="Comment">   * pieces. This allows the user to provide partial hints for merge situations.</span>
<span class="lnr">118 </span><span class="Comment">   * *)</span>
<span class="lnr">119 </span>  <span class="Keyword">match</span> ov <span class="Keyword">with</span>
<span class="lnr">120 </span>  <span class="Keyword">|</span> <span class="Constant">None</span> <span class="Keyword">-&gt;</span>
<span class="lnr">121 </span>      b
<span class="lnr">122 </span>  <span class="Keyword">|</span> <span class="Constant">Some</span> <span class="Keyword">{</span> contents <span class="Keyword">=</span> v <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr">123 </span>      <span class="Constant">BCons</span> <span class="Keyword">{</span> key <span class="Keyword">=</span> x<span class="Keyword">;</span> value <span class="Keyword">=</span> v<span class="Keyword">;</span> tail <span class="Keyword">=</span> b <span class="Keyword">}</span>
<span class="lnr">124 </span>  <span class="Keyword">end</span>
<span class="lnr">125 </span>
<span class="lnr">126 </span><span class="Comment">(* Update or removal of the list head. *)</span>
<span class="lnr">127 </span>
<span class="lnr">128 </span><span class="Keyword">val</span> update_or_remove <span class="Keyword">[</span>k, a<span class="Keyword">]</span> <span class="Keyword">(</span>
<span class="lnr">129 </span>  <span class="Keyword">consumes</span> b: <span class="Constant">BCons</span> <span class="Keyword">{</span> key: k<span class="Keyword">;</span> value: <span class="Keyword">unknown</span><span class="Keyword">;</span> tail: bucket k a <span class="Keyword">}</span>,
<span class="lnr">130 </span>  <span class="Keyword">consumes</span> ov: <span class="Type">option</span> a
<span class="lnr">131 </span><span class="Keyword">)</span> : bucket k a <span class="Keyword">=</span>
<span class="lnr">132 </span>  <span class="Keyword">match</span> ov <span class="Keyword">with</span>
<span class="lnr">133 </span>  <span class="Keyword">|</span> <span class="Constant">None</span> <span class="Keyword">-&gt;</span>
<span class="lnr">134 </span>      b.tail
<span class="lnr">135 </span>  <span class="Keyword">|</span> <span class="Constant">Some</span> <span class="Keyword">{</span> contents <span class="Keyword">=</span> v <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr">136 </span>      b.value <span class="Keyword">&lt;-</span> v<span class="Keyword">;</span>
<span class="lnr">137 </span>      b
<span class="lnr">138 </span>  <span class="Keyword">end</span>
<span class="lnr">139 </span>
<span class="lnr">140 </span><span class="Comment">(* -------------------------------------------------------------------------- *)</span>
<span class="lnr">141 </span>
<span class="lnr">142 </span><span class="Comment">(* Update. *)</span>
<span class="lnr">143 </span>
<span class="lnr">144 </span><span class="Comment">(* [update (equal, b, x, f)] looks for an entry whose key is [equal] to [x]</span>
<span class="lnr">145 </span><span class="Comment">   in the bucket [b]. It calls the user-supplied function [f] exactly once,</span>
<span class="lnr">146 </span><span class="Comment">   and passes it either the value [v] that is associated with the key [x],</span>
<span class="lnr">147 </span><span class="Comment">   or nothing, if the key [x] does not appear in the bucket. The function</span>
<span class="lnr">148 </span><span class="Comment">   [f] returns either a new value, or nothing. In the former case, the new</span>
<span class="lnr">149 </span><span class="Comment">   value replaces the value [v]. In the latter case, the key [x] is removed</span>
<span class="lnr">150 </span><span class="Comment">   (if it was there at all). An updated bucket is returned. *)</span>
<span class="lnr">151 </span>
<span class="lnr">152 </span><span class="Keyword">val</span> update <span class="Keyword">[</span>k, a, pre : <span class="Keyword">perm</span>, post : <span class="Keyword">perm]</span> <span class="Keyword">(</span>
<span class="lnr">153 </span>  equal: <span class="Keyword">(</span>k, k<span class="Keyword">)</span> <span class="Keyword">-&gt;</span> <span class="Type">bool</span>,
<span class="lnr">154 </span>  <span class="Keyword">consumes</span> b: bucket k a,
<span class="lnr">155 </span>  <span class="Keyword">consumes</span> x: k,
<span class="lnr">156 </span>  f: <span class="Keyword">(consumes</span> <span class="Keyword">(</span><span class="Type">option</span> a <span class="Keyword">|</span> pre<span class="Keyword">))</span> <span class="Keyword">-&gt;</span> <span class="Keyword">(</span><span class="Type">option</span> a <span class="Keyword">|</span> post<span class="Keyword">)</span>
<span class="lnr">157 </span>  <span class="Keyword">|</span> <span class="Keyword">consumes</span> pre
<span class="lnr">158 </span><span class="Keyword">)</span> : <span class="Keyword">(</span>bucket k a <span class="Keyword">|</span> post<span class="Keyword">)</span> <span class="Keyword">=</span>
<span class="lnr">159 </span>
<span class="lnr">160 </span>  <span class="Comment">(* Write a loop that works over two consecutive cells. We work under the</span>
<span class="lnr">161 </span><span class="Comment">     assumption that [prev] does not satisfy [ok], so it remains the list</span>
<span class="lnr">162 </span><span class="Comment">     head after the loop. *)</span>
<span class="lnr">163 </span>  <span class="Keyword">let</span> <span class="Keyword">rec</span> loop <span class="Keyword">(</span>
<span class="lnr">164 </span>    <span class="Keyword">consumes</span> prev: <span class="Constant">BCons</span> <span class="Keyword">{</span> key: k<span class="Keyword">;</span> value: a<span class="Keyword">;</span> tail <span class="Keyword">=</span> this <span class="Keyword">}</span>,
<span class="lnr">165 </span>    <span class="Keyword">consumes</span> this: bucket k a
<span class="lnr">166 </span>  <span class="Keyword">|</span> <span class="Keyword">consumes</span> x @ k <span class="Keyword">*</span> <span class="Keyword">consumes</span> pre
<span class="lnr">167 </span>  <span class="Keyword">)</span> : <span class="Keyword">(</span><span class="Keyword">|</span> prev @ bucket k a <span class="Keyword">|</span> post<span class="Keyword">)</span> <span class="Keyword">=</span>
<span class="lnr">168 </span>    <span class="Keyword">match</span> this <span class="Keyword">with</span>
<span class="lnr">169 </span>    <span class="Keyword">|</span> <span class="Constant">BNil</span> <span class="Keyword">-&gt;</span>
<span class="lnr">170 </span>        <span class="Comment">(* The desired key was not found. Invoke [f] with argument [none]. *)</span>
<span class="lnr">171 </span>        prev.tail <span class="Keyword">&lt;-</span> insert <span class="Keyword">(</span>x, f none, this<span class="Keyword">)</span>
<span class="lnr">172 </span>    <span class="Keyword">|</span> <span class="Constant">BCons</span> <span class="Keyword">{</span> key<span class="Keyword">;</span> value <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr">173 </span>        <span class="Keyword">if</span> equal <span class="Keyword">(</span>x, key<span class="Keyword">)</span> <span class="Keyword">then</span>
<span class="lnr">174 </span>          <span class="Comment">(* The desired key was found. Invoke [f] with argument [some value]. *)</span>
<span class="lnr">175 </span>          prev.tail <span class="Keyword">&lt;-</span> update_or_remove <span class="Keyword">(</span>this, f <span class="Keyword">(</span>some value<span class="Keyword">))</span>
<span class="lnr">176 </span>        <span class="Keyword">else</span>
<span class="lnr">177 </span>          loop <span class="Keyword">(</span>this, this.tail<span class="Keyword">)</span>
<span class="lnr">178 </span>    <span class="Keyword">end</span>
<span class="lnr">179 </span>  <span class="Keyword">in</span>
<span class="lnr">180 </span>
<span class="lnr">181 </span>  <span class="Keyword">match</span> b <span class="Keyword">with</span>
<span class="lnr">182 </span>  <span class="Keyword">|</span> <span class="Constant">BNil</span> <span class="Keyword">-&gt;</span>
<span class="lnr">183 </span>      <span class="Comment">(* The desired key was not found. Invoke [f] with argument [none]. *)</span>
<span class="lnr">184 </span>      insert <span class="Keyword">(</span>x, f none, b<span class="Keyword">)</span>
<span class="lnr">185 </span>  <span class="Keyword">|</span> <span class="Constant">BCons</span> <span class="Keyword">{</span> key<span class="Keyword">;</span> value <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr">186 </span>      <span class="Keyword">if</span> equal <span class="Keyword">(</span>x, key<span class="Keyword">)</span> <span class="Keyword">then</span>
<span class="lnr">187 </span>        <span class="Comment">(* The desired key was found. Invoke [f] with argument [some value]. *)</span>
<span class="lnr">188 </span>        update_or_remove <span class="Keyword">(</span>b, f <span class="Keyword">(</span>some value<span class="Keyword">))</span>
<span class="lnr">189 </span>      <span class="Keyword">else</span> <span class="Keyword">begin</span>
<span class="lnr">190 </span>        <span class="Comment">(* Otherwise, enter the above loop. The list head does not change. *)</span>
<span class="lnr">191 </span>        loop <span class="Keyword">(</span>b, b.tail<span class="Keyword">)</span><span class="Keyword">;</span>
<span class="lnr">192 </span>        b
<span class="lnr">193 </span>      <span class="Keyword">end</span>
<span class="lnr">194 </span>  <span class="Keyword">end</span>
<span class="lnr">195 </span>
<span class="lnr">196 </span><span class="Comment">(* -------------------------------------------------------------------------- *)</span>
<span class="lnr">197 </span>
<span class="lnr">198 </span><span class="Comment">(* Iteration. *)</span>
<span class="lnr">199 </span>
<span class="lnr">200 </span><span class="Comment">(* Non-destructive iteration over the elements of a bucket. *)</span>
<span class="lnr">201 </span>
<span class="lnr">202 </span><span class="Comment">(* For simplicity, we assign [fold] a type that does not allow performing</span>
<span class="lnr">203 </span><span class="Comment">   a strong update on the keys or values. A more general type exists. *)</span>
<span class="lnr">204 </span>
<span class="lnr">205 </span><span class="Keyword">val</span> <span class="Keyword">rec</span> fold <span class="Keyword">[</span>k, a, b<span class="Keyword">]</span> <span class="Keyword">(</span>
<span class="lnr">206 </span>  this: bucket k a,
<span class="lnr">207 </span>  <span class="Keyword">consumes</span> accu: b,
<span class="lnr">208 </span>  f: <span class="Keyword">(</span>k, a, <span class="Keyword">consumes</span> b<span class="Keyword">)</span> <span class="Keyword">-&gt;</span> b
<span class="lnr">209 </span><span class="Keyword">)</span> : b <span class="Keyword">=</span>
<span class="lnr">210 </span>  <span class="Keyword">match</span> this <span class="Keyword">with</span>
<span class="lnr">211 </span>  <span class="Keyword">|</span> <span class="Constant">BNil</span> <span class="Keyword">-&gt;</span>
<span class="lnr">212 </span>      accu
<span class="lnr">213 </span>  <span class="Keyword">|</span> <span class="Constant">BCons</span> <span class="Keyword">{</span> key<span class="Keyword">;</span> value<span class="Keyword">;</span> tail <span class="Keyword">}</span> <span class="Keyword">-&gt;</span>
<span class="lnr">214 </span>      fold <span class="Keyword">(</span>tail, f <span class="Keyword">(</span>key, value, accu<span class="Keyword">)</span>, f<span class="Keyword">)</span>
<span class="lnr">215 </span>  <span class="Keyword">end</span>
<span class="lnr">216 </span>
<span class="lnr">217 </span><span class="Comment">(* -------------------------------------------------------------------------- *)</span>
<span class="lnr">218 </span>
<span class="lnr">219 </span><span class="Comment">(* Destructive iteration over the cells of a bucket. Each cell is presented in</span>
<span class="lnr">220 </span><span class="Comment">   turn to the function [f]. Note that the cells that are presented to [f] are</span>
<span class="lnr">221 </span><span class="Comment">   detached, i.e., their [tail] field is garbage. *)</span>
<span class="lnr">222 </span>
<span class="lnr">223 </span><span class="Keyword">val</span> <span class="Keyword">rec</span> iter_bucket_down <span class="Keyword">[</span>k, a, p : <span class="Keyword">perm]</span> <span class="Keyword">(</span>
<span class="lnr">224 </span>  <span class="Keyword">consumes</span> b: bucket k a,
<span class="lnr">225 </span>  f: <span class="Keyword">(consumes</span> b: <span class="Constant">BCons</span> <span class="Keyword">{</span> key: k<span class="Keyword">;</span> value: a<span class="Keyword">;</span> tail: <span class="Keyword">unknown</span> <span class="Keyword">}</span> <span class="Keyword">|</span> p<span class="Keyword">)</span> <span class="Keyword">-&gt;</span> <span class="Constant">()</span>
<span class="lnr">226 </span>  <span class="Keyword">|</span> p
<span class="lnr">227 </span><span class="Keyword">)</span> : <span class="Constant">()</span> <span class="Keyword">=</span>
<span class="lnr">228 </span>  <span class="Keyword">match</span> b <span class="Keyword">with</span>
<span class="lnr">229 </span>  <span class="Keyword">|</span> <span class="Constant">BNil</span> <span class="Keyword">-&gt;</span>
<span class="lnr">230 </span>      <span class="Constant">()</span>
<span class="lnr">231 </span>  <span class="Keyword">|</span> <span class="Constant">BCons</span> <span class="Keyword">-&gt;</span>
<span class="lnr">232 </span>      <span class="Comment">(* Iteration from the end down to the beginning of the list. *)</span>
<span class="lnr">233 </span>      iter_bucket_down <span class="Keyword">(</span>b.tail, f<span class="Keyword">)</span><span class="Keyword">;</span>
<span class="lnr">234 </span>      f b
<span class="lnr">235 </span>  <span class="Keyword">end</span>
<span class="lnr">236 </span>
<span class="lnr">237 </span><span class="Comment">(* -------------------------------------------------------------------------- *)</span>
<span class="lnr">238 </span>
<span class="lnr">239 </span><span class="Comment">(* Length. *)</span>
<span class="lnr">240 </span>
<span class="lnr">241 </span><span class="Keyword">val</span> length <span class="Keyword">[</span>k, a<span class="Keyword">]</span> <span class="Keyword">(</span>b: bucket k a<span class="Keyword">)</span> : <span class="Type">int</span> <span class="Keyword">=</span>
<span class="lnr">242 </span>  <span class="Keyword">let</span> <span class="Keyword">rec</span> loop <span class="Keyword">(</span>b: bucket k a, accu: <span class="Type">int</span><span class="Keyword">)</span> : <span class="Type">int</span> <span class="Keyword">=</span>
<span class="lnr">243 </span>    <span class="Keyword">match</span> b <span class="Keyword">with</span>
<span class="lnr">244 </span>    <span class="Keyword">|</span> <span class="Constant">BNil</span> <span class="Keyword">-&gt;</span>
<span class="lnr">245 </span>        accu
<span class="lnr">246 </span>    <span class="Keyword">|</span> <span class="Constant">BCons</span> <span class="Keyword">-&gt;</span>
<span class="lnr">247 </span>        loop <span class="Keyword">(</span>b.tail, accu + <span class="Number">1</span><span class="Keyword">)</span>
<span class="lnr">248 </span>    <span class="Keyword">end</span>
<span class="lnr">249 </span>  <span class="Keyword">in</span>
<span class="lnr">250 </span>  loop <span class="Keyword">(</span>b, <span class="Number">0</span><span class="Keyword">)</span>
<span class="lnr">251 </span>
<span class="lnr">252 </span><span class="Comment">(*</span>
<span class="lnr">253 </span><span class="Comment">Local Variables:</span>
<span class="lnr">254 </span><span class="Comment">compile-command: &quot;../mezzo bucket.mz&quot;</span>
<span class="lnr">255 </span><span class="Comment">End:</span>
<span class="lnr">256 </span><span class="Comment">*)</span>
</pre>
</body>
</html>
