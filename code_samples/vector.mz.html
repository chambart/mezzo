<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>/home/jonathan/Code/mezzo/src/stdlib/vector.mz.html</title>
<meta name="Generator" content="Vim/7.3">
<meta name="plugin-version" content="vim7.3_v10">
<meta name="syntax" content="mezzo">
<meta name="settings" content="number_lines,use_css,expand_tabs">
<style type="text/css">
<!--
pre { font-family: monospace; color: #f6f3e8; background-color: #242424; }
body { font-family: monospace; color: #f6f3e8; background-color: #242424; }
.lnr { color: #857b6f; background-color: #000000; }
.Number { color: #e5786d; }
.Type { color: #cae682; }
.Constant { color: #e5786d; }
.Keyword { color: #8ac6f2; }
.Comment { color: #99968b; font-style: italic; }
-->
</style>
</head>
<body>
<pre>
<span class="lnr">  1 </span><span class="Comment">(* This module implements resizable arrays, also known as vectors,</span>
<span class="lnr">  2 </span><span class="Comment">   for short. *)</span>
<span class="lnr">  3 </span>
<span class="lnr">  4 </span><span class="Keyword">mutable</span> <span class="Keyword">data</span> vector a <span class="Keyword">=</span>
<span class="lnr">  5 </span>  <span class="Constant">Vector</span> <span class="Keyword">{</span>
<span class="lnr">  6 </span>    <span class="Comment">(* A default function, used to initialize new locations when the</span>
<span class="lnr">  7 </span><span class="Comment">       vector is enlarged. *)</span>
<span class="lnr">  8 </span>    default: <span class="Type">int</span> <span class="Keyword">-&gt;</span> a<span class="Keyword">;</span>
<span class="lnr">  9 </span>    <span class="Comment">(* The array's logical size. It is always less than or equal</span>
<span class="lnr"> 10 </span><span class="Comment">       to the length of the array [table]. *)</span>
<span class="lnr"> 11 </span>    size: <span class="Type">int</span><span class="Keyword">;</span>
<span class="lnr"> 12 </span>    <span class="Comment">(* The underlying array. The length of this array is arbitrary,</span>
<span class="lnr"> 13 </span><span class="Comment">       but is of course at least [size]. *)</span>
<span class="lnr"> 14 </span>    <span class="Comment">(* For the moment, I am using an array of options, with the</span>
<span class="lnr"> 15 </span><span class="Comment">       invariant property that every slot below [size] is [Some].</span>
<span class="lnr"> 16 </span><span class="Comment">       If we had permissions for array segments, then we would be</span>
<span class="lnr"> 17 </span><span class="Comment">       able to encode this invariant and get rid of the option,</span>
<span class="lnr"> 18 </span><span class="Comment">       I suppose. TEMPORARY that would be nice! *)</span>
<span class="lnr"> 19 </span>    table: <span class="Type">array</span> <span class="Keyword">(</span><span class="Type">option</span> a<span class="Keyword">)</span>
<span class="lnr"> 20 </span>  <span class="Keyword">}</span>
<span class="lnr"> 21 </span>
<span class="lnr"> 22 </span><span class="Keyword">val</span> minimum_length <span class="Keyword">=</span>
<span class="lnr"> 23 </span>  <span class="Number">16</span> <span class="Comment">(* must be non-zero *)</span>
<span class="lnr"> 24 </span>
<span class="lnr"> 25 </span><span class="Keyword">val</span> new_length <span class="Keyword">(</span>length: <span class="Type">int</span>, size: <span class="Type">int</span><span class="Keyword">)</span> : <span class="Type">int</span> <span class="Keyword">=</span>
<span class="lnr"> 26 </span>  <span class="Comment">(* By default, we double the vector's length until it reaches the</span>
<span class="lnr"> 27 </span><span class="Comment">     requested size or exceeds [array::max_length]. *)</span>
<span class="lnr"> 28 </span>  <span class="Keyword">let</span> length <span class="Keyword">=</span>
<span class="lnr"> 29 </span>    max <span class="Keyword">(</span>
<span class="lnr"> 30 </span>      minimum_length,
<span class="lnr"> 31 </span>      <span class="Keyword">(</span><span class="Type">array</span><span class="Keyword">::</span>above <span class="Keyword">(</span>length, size<span class="Keyword">))</span>
<span class="lnr"> 32 </span>    <span class="Keyword">)</span>
<span class="lnr"> 33 </span>  <span class="Keyword">in</span>
<span class="lnr"> 34 </span>  <span class="Keyword">if</span> size <span class="Keyword">&lt;</span><span class="Keyword">=</span> length <span class="Keyword">then</span>
<span class="lnr"> 35 </span>    length
<span class="lnr"> 36 </span>  <span class="Keyword">else</span> <span class="Keyword">if</span> size <span class="Keyword">&lt;</span><span class="Keyword">=</span> <span class="Type">array</span><span class="Keyword">::</span>max_length <span class="Keyword">then</span>
<span class="lnr"> 37 </span>    size
<span class="lnr"> 38 </span>  <span class="Keyword">else</span>
<span class="lnr"> 39 </span>    <span class="Comment">(* The requested size is too large. *)</span>
<span class="lnr"> 40 </span>    <span class="Keyword">fail</span>
<span class="lnr"> 41 </span>
<span class="lnr"> 42 </span><span class="Keyword">val</span> init <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">(</span>size: <span class="Type">int</span>, default: <span class="Type">int</span> <span class="Keyword">-&gt;</span> a, f: <span class="Type">int</span> <span class="Keyword">-&gt;</span> a<span class="Keyword">)</span> : vector a <span class="Keyword">=</span>
<span class="lnr"> 43 </span>  <span class="Keyword">let</span> length <span class="Keyword">=</span> new_length <span class="Keyword">(</span><span class="Number">0</span>, size<span class="Keyword">)</span> <span class="Keyword">in</span>
<span class="lnr"> 44 </span>  <span class="Constant">Vector</span> <span class="Keyword">{</span>
<span class="lnr"> 45 </span>    default <span class="Keyword">=</span> default<span class="Keyword">;</span>
<span class="lnr"> 46 </span>    size <span class="Keyword">=</span> size<span class="Keyword">;</span>
<span class="lnr"> 47 </span>    table <span class="Keyword">=</span> <span class="Type">array</span><span class="Keyword">::</span>init <span class="Keyword">(</span><span class="Constant">Up</span>, length, <span class="Keyword">fun</span> <span class="Keyword">(</span>i: <span class="Type">int</span><span class="Keyword">)</span> : <span class="Type">option</span> a <span class="Keyword">=</span>
<span class="lnr"> 48 </span>      <span class="Keyword">if</span> i <span class="Keyword">&lt;</span> size <span class="Keyword">then</span> some <span class="Keyword">(</span>f i<span class="Keyword">)</span> <span class="Keyword">else</span> <span class="Constant">None</span>
<span class="lnr"> 49 </span>    <span class="Keyword">)</span>
<span class="lnr"> 50 </span>  <span class="Keyword">}</span>
<span class="lnr"> 51 </span>
<span class="lnr"> 52 </span><span class="Keyword">val</span> grab <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">(consumes</span> r: <span class="Type">array</span> a, default: <span class="Type">int</span> <span class="Keyword">-&gt;</span> a<span class="Keyword">)</span> : vector a <span class="Keyword">=</span>
<span class="lnr"> 53 </span>  <span class="Comment">(* We take the ownership of [r]. We replace every element [x]</span>
<span class="lnr"> 54 </span><span class="Comment">     with [some x], so as to make it an array of type [option a]. *)</span>
<span class="lnr"> 55 </span>  <span class="Type">array</span><span class="Keyword">::</span>transform <span class="Keyword">(</span><span class="Constant">Up</span>, r, <span class="Keyword">fun</span> <span class="Keyword">(</span><span class="Keyword">_</span>: <span class="Type">int</span>, <span class="Keyword">consumes</span> x: a<span class="Keyword">)</span> : <span class="Type">option</span> a <span class="Keyword">=</span> some x<span class="Keyword">)</span><span class="Keyword">;</span>
<span class="lnr"> 56 </span>  <span class="Constant">Vector</span> <span class="Keyword">{</span>
<span class="lnr"> 57 </span>    default <span class="Keyword">=</span> default<span class="Keyword">;</span>
<span class="lnr"> 58 </span>    size <span class="Keyword">=</span> <span class="Type">array</span><span class="Keyword">::</span>length r<span class="Keyword">;</span>
<span class="lnr"> 59 </span>    table <span class="Keyword">=</span> r
<span class="lnr"> 60 </span>  <span class="Keyword">}</span>
<span class="lnr"> 61 </span>
<span class="lnr"> 62 </span><span class="Keyword">val</span> list2vector <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">(consumes</span> xs: <span class="Type">list</span><span class="Keyword">::</span><span class="Type">list</span> a, default: <span class="Type">int</span> <span class="Keyword">-&gt;</span> a<span class="Keyword">)</span> : vector a <span class="Keyword">=</span>
<span class="lnr"> 63 </span>  grab <span class="Keyword">(</span><span class="Type">list</span><span class="Keyword">::</span>list2array xs, default<span class="Keyword">)</span>
<span class="lnr"> 64 </span>
<span class="lnr"> 65 </span><span class="Keyword">val</span> create <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">(</span>default: <span class="Type">int</span> <span class="Keyword">-&gt;</span> a<span class="Keyword">)</span> : vector a <span class="Keyword">=</span>
<span class="lnr"> 66 </span>  init <span class="Keyword">(</span><span class="Number">0</span>, default, <span class="Keyword">fun</span> <span class="Keyword">(</span>i : <span class="Type">int</span><span class="Keyword">)</span> : a <span class="Keyword">=</span> <span class="Keyword">fail)</span>
<span class="lnr"> 67 </span>
<span class="lnr"> 68 </span><span class="Keyword">val</span> size <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">(</span>v: vector a<span class="Keyword">)</span> : <span class="Type">int</span> <span class="Keyword">=</span>
<span class="lnr"> 69 </span>  v.size
<span class="lnr"> 70 </span>
<span class="lnr"> 71 </span><span class="Keyword">val</span> resize <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">(</span>v: vector a, new_size: <span class="Type">int</span><span class="Keyword">)</span> : <span class="Constant">()</span> <span class="Keyword">=</span>
<span class="lnr"> 72 </span>  <span class="Keyword">if</span> new_size <span class="Keyword">&lt;</span> <span class="Number">0</span> <span class="Keyword">then</span>
<span class="lnr"> 73 </span>    <span class="Keyword">fail</span><span class="Keyword">;</span>
<span class="lnr"> 74 </span>  <span class="Keyword">let</span> old_size <span class="Keyword">=</span> v.size <span class="Keyword">in</span>
<span class="lnr"> 75 </span>  <span class="Keyword">if</span> new_size <span class="Keyword">&lt;&gt;</span> old_size <span class="Keyword">then</span> <span class="Keyword">begin</span>
<span class="lnr"> 76 </span>    <span class="Comment">(* Update the logical size of the vector. *)</span>
<span class="lnr"> 77 </span>    v.size <span class="Keyword">&lt;-</span> new_size<span class="Keyword">;</span>
<span class="lnr"> 78 </span>    <span class="Keyword">let</span> table <span class="Keyword">=</span> v.table <span class="Keyword">in</span>
<span class="lnr"> 79 </span>    <span class="Keyword">if</span> new_size <span class="Keyword">&lt;</span> old_size <span class="Keyword">then</span>
<span class="lnr"> 80 </span>      <span class="Comment">(* The logical size of the vector decreases. *)</span>
<span class="lnr"> 81 </span>      <span class="Comment">(* Avoid a memory leak. *)</span>
<span class="lnr"> 82 </span>      <span class="Comment">(* TEMPORARY we would like to use:</span>
<span class="lnr"> 83 </span><span class="Comment">         array::fill_segment (table, new_size, n, None);</span>
<span class="lnr"> 84 </span><span class="Comment">         but this is not currently possible, see comment in [array.mz];</span>
<span class="lnr"> 85 </span><span class="Comment">         so, instead, we must use an explicit loop: *)</span>
<span class="lnr"> 86 </span>      <span class="Type">array</span><span class="Keyword">::</span>iter_segment <span class="Keyword">(</span><span class="Constant">Up</span>, new_size, old_size, <span class="Keyword">fun</span> <span class="Keyword">(</span>k: <span class="Type">int</span> <span class="Keyword">|</span> table @ <span class="Type">array</span> <span class="Keyword">(</span><span class="Type">option</span> a<span class="Keyword">))</span> : <span class="Constant">()</span> <span class="Keyword">=</span>
<span class="lnr"> 87 </span>          <span class="Type">array</span><span class="Keyword">::</span>set <span class="Keyword">(</span>table, k, <span class="Constant">None</span><span class="Keyword">)</span>
<span class="lnr"> 88 </span>      <span class="Keyword">)</span>
<span class="lnr"> 89 </span>    <span class="Keyword">else</span> <span class="Keyword">begin</span>
<span class="lnr"> 90 </span>      <span class="Comment">(* The logical size of the vector increases. *)</span>
<span class="lnr"> 91 </span>      v.size <span class="Keyword">&lt;-</span> new_size<span class="Keyword">;</span>
<span class="lnr"> 92 </span>      <span class="Keyword">let</span> old_length <span class="Keyword">=</span> <span class="Type">array</span><span class="Keyword">::</span>length table <span class="Keyword">in</span>
<span class="lnr"> 93 </span>      <span class="Keyword">if</span> new_size <span class="Keyword">&gt;</span> old_length <span class="Keyword">then</span> <span class="Keyword">begin</span>
<span class="lnr"> 94 </span>        <span class="Keyword">let</span> new_length <span class="Keyword">=</span> new_length <span class="Keyword">(</span>old_length, new_size<span class="Keyword">)</span> <span class="Keyword">in</span>
<span class="lnr"> 95 </span>        <span class="Comment">(* The physical size of the array must increase. *)</span>
<span class="lnr"> 96 </span>        <span class="Comment">(* The array [table'] is initialized with [None], a duplicable value,</span>
<span class="lnr"> 97 </span><span class="Comment">           so [array::create] can be used. Thus, [table'] has type [array None].</span>
<span class="lnr"> 98 </span><span class="Comment">           Because [array] is covariant, [table'] also has type [array (option a)],</span>
<span class="lnr"> 99 </span><span class="Comment">           and is a suitable argument for [array::steal]. *)</span>
<span class="lnr">100 </span>        <span class="Keyword">let</span> table' <span class="Keyword">=</span> <span class="Type">array</span><span class="Keyword">::</span>create <span class="Keyword">[</span><span class="Constant">None</span><span class="Keyword">]</span> <span class="Keyword">(</span>new_length, <span class="Constant">None</span><span class="Keyword">)</span> <span class="Keyword">in</span>
<span class="lnr">101 </span>        <span class="Type">array</span><span class="Keyword">::</span>steal <span class="Keyword">[</span><span class="Type">option</span> a<span class="Keyword">]</span> <span class="Keyword">(</span>table, table', <span class="Number">0</span><span class="Keyword">)</span><span class="Keyword">;</span>
<span class="lnr">102 </span>        v.table <span class="Keyword">&lt;-</span> table'
<span class="lnr">103 </span>      <span class="Keyword">end</span><span class="Keyword">;</span>
<span class="lnr">104 </span>      <span class="Comment">(* Initialize the new elements. *)</span>
<span class="lnr">105 </span>      <span class="Type">array</span><span class="Keyword">::</span>iter_segment <span class="Keyword">(</span><span class="Constant">Up</span>, old_size, new_size, <span class="Keyword">fun</span> <span class="Keyword">(</span>k: <span class="Type">int</span> <span class="Keyword">|</span> v @ vector a<span class="Keyword">)</span> : <span class="Constant">()</span> <span class="Keyword">=</span>
<span class="lnr">106 </span>        <span class="Type">array</span><span class="Keyword">::</span>set <span class="Keyword">(</span>v.table, k, some <span class="Keyword">(</span>v.default k<span class="Keyword">))</span>
<span class="lnr">107 </span>      <span class="Keyword">)</span>
<span class="lnr">108 </span>    <span class="Keyword">end</span>
<span class="lnr">109 </span>  <span class="Keyword">end</span>
<span class="lnr">110 </span>
<span class="lnr">111 </span><span class="Keyword">val</span> shrink <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">(</span>v: vector a, delta: <span class="Type">int</span><span class="Keyword">)</span> : <span class="Constant">()</span> <span class="Keyword">=</span>
<span class="lnr">112 </span>  <span class="Keyword">if</span> delta <span class="Keyword">&lt;</span> <span class="Number">0</span> <span class="Keyword">then</span>
<span class="lnr">113 </span>    <span class="Keyword">fail</span><span class="Keyword">;</span>
<span class="lnr">114 </span>  resize <span class="Keyword">(</span>v, size v - delta<span class="Keyword">)</span>
<span class="lnr">115 </span>
<span class="lnr">116 </span><span class="Keyword">val</span> pop <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">(</span>v: vector a<span class="Keyword">)</span> : <span class="Constant">()</span> <span class="Keyword">=</span>
<span class="lnr">117 </span>  resize <span class="Keyword">(</span>v, size v - <span class="Number">1</span><span class="Keyword">)</span>
<span class="lnr">118 </span>
<span class="lnr">119 </span><span class="Keyword">val</span> get <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">duplicable</span> a <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Keyword">(</span>v: vector a, i: <span class="Type">int</span><span class="Keyword">)</span> : a <span class="Keyword">=</span>
<span class="lnr">120 </span>  <span class="Keyword">if</span> i <span class="Keyword">&gt;</span><span class="Keyword">=</span> <span class="Number">0</span> <span class="Keyword">&amp;&amp;</span> i <span class="Keyword">&lt;</span> v.size <span class="Keyword">then</span>
<span class="lnr">121 </span>    <span class="Type">option</span><span class="Keyword">::</span>force <span class="Keyword">(</span><span class="Type">array</span><span class="Keyword">::</span>get <span class="Keyword">(</span>v.table, i<span class="Keyword">))</span>
<span class="lnr">122 </span>  <span class="Keyword">else</span>
<span class="lnr">123 </span>    <span class="Keyword">fail</span>
<span class="lnr">124 </span>
<span class="lnr">125 </span><span class="Keyword">val</span> set <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">(</span>v: vector a, i: <span class="Type">int</span>, <span class="Keyword">consumes</span> x: a<span class="Keyword">)</span> : <span class="Constant">()</span> <span class="Keyword">=</span>
<span class="lnr">126 </span>  <span class="Keyword">if</span> i <span class="Keyword">&gt;</span><span class="Keyword">=</span> <span class="Number">0</span> <span class="Keyword">&amp;&amp;</span> i <span class="Keyword">&lt;</span> v.size <span class="Keyword">then</span>
<span class="lnr">127 </span>    <span class="Type">array</span><span class="Keyword">::</span>set <span class="Keyword">(</span>v.table, i, some x<span class="Keyword">)</span>
<span class="lnr">128 </span>  <span class="Keyword">else</span>
<span class="lnr">129 </span>    <span class="Keyword">fail</span>
<span class="lnr">130 </span>
<span class="lnr">131 </span><span class="Keyword">val</span> push <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">(</span>v: vector a, <span class="Keyword">consumes</span> x: a<span class="Keyword">)</span> : <span class="Constant">()</span> <span class="Keyword">=</span>
<span class="lnr">132 </span>  <span class="Keyword">let</span> i <span class="Keyword">=</span> size v <span class="Keyword">in</span>
<span class="lnr">133 </span>  resize <span class="Keyword">(</span>v, i + <span class="Number">1</span><span class="Keyword">)</span><span class="Keyword">;</span>
<span class="lnr">134 </span>  <span class="Type">array</span><span class="Keyword">::</span>set <span class="Keyword">(</span>v.table, i, some x<span class="Keyword">)</span>
<span class="lnr">135 </span>
<span class="lnr">136 </span><span class="Keyword">val</span> last <span class="Keyword">[</span>a<span class="Keyword">]</span> <span class="Keyword">duplicable</span> a <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Keyword">(</span>v: vector a<span class="Keyword">)</span> : a <span class="Keyword">=</span>
<span class="lnr">137 </span>  get <span class="Keyword">(</span>v, size v - <span class="Number">1</span><span class="Keyword">)</span>
<span class="lnr">138 </span>
<span class="lnr">139 </span><span class="Keyword">val</span> sort <span class="Keyword">[</span>a, p : <span class="Keyword">perm]</span> <span class="Keyword">duplicable</span> a <span class="Keyword">=</span><span class="Keyword">&gt;</span> <span class="Keyword">(</span>v: vector a, cmp: <span class="Keyword">(</span>a, a <span class="Keyword">|</span> p<span class="Keyword">)</span> <span class="Keyword">-&gt;</span> <span class="Type">int</span> <span class="Keyword">|</span> p<span class="Keyword">)</span> : <span class="Constant">()</span> <span class="Keyword">=</span>
<span class="lnr">140 </span>  <span class="Comment">(* We must define a comparison function over options. *)</span>
<span class="lnr">141 </span>  <span class="Keyword">let</span> cmp <span class="Keyword">(</span>x: <span class="Type">option</span> a, y: <span class="Type">option</span> a <span class="Keyword">|</span> p<span class="Keyword">)</span> : <span class="Type">int</span> <span class="Keyword">=</span>
<span class="lnr">142 </span>    cmp <span class="Keyword">(</span><span class="Type">option</span><span class="Keyword">::</span>force x, <span class="Type">option</span><span class="Keyword">::</span>force y<span class="Keyword">)</span>
<span class="lnr">143 </span>  <span class="Keyword">in</span>
<span class="lnr">144 </span>  <span class="Comment">(* The cool thing is, we do not need to copy the array in order to</span>
<span class="lnr">145 </span><span class="Comment">     sort an initial segment of it. *)</span>
<span class="lnr">146 </span>  <span class="Type">array</span><span class="Keyword">::</span>sort_initial_segment <span class="Keyword">(</span>cmp, v.table, v.size<span class="Keyword">)</span>
<span class="lnr">147 </span>
<span class="lnr">148 </span><span class="Comment">(* TEMPORARY ideally, we should provide more operations over vectors,</span>
<span class="lnr">149 </span><span class="Comment">   taking inspiration from the array library. Can we avoid duplication?</span>
<span class="lnr">150 </span><span class="Comment">   One option would be for the vector to expose the underlying array;</span>
<span class="lnr">151 </span><span class="Comment">   this would be somewhat inelegant, but less dangerous than in a normal</span>
<span class="lnr">152 </span><span class="Comment">   programming language, because the type-checker would check that the</span>
<span class="lnr">153 </span><span class="Comment">   ownership of the array is returned before the vector can be used again.</span>
<span class="lnr">154 </span><span class="Comment">   Another option would be to to define a library of operations that work</span>
<span class="lnr">155 </span><span class="Comment">   uniformly on arrays, vectors, and other random access containers. *)</span>
<span class="lnr">156 </span>
<span class="lnr">157 </span><span class="Comment">(* API differences with Cubicle's common/vec.ml:</span>
<span class="lnr">158 </span>
<span class="lnr">159 </span><span class="Comment">   Vec.get raises Not_found if the element is equal to the default element</span>
<span class="lnr">160 </span><span class="Comment">   (this seems strange, and I don't think this feature is exploited).</span>
<span class="lnr">161 </span>
<span class="lnr">162 </span><span class="Comment">   Vec.set automatically increases the array's logical size if required but</span>
<span class="lnr">163 </span><span class="Comment">   does not increase its physical length (this seems strange). Our function</span>
<span class="lnr">164 </span><span class="Comment">   vector::set does not do this; vector::resize must be called first.</span>
<span class="lnr">165 </span>
<span class="lnr">166 </span><span class="Comment">   Vec.grow_to_by_double is a bit strange, because it increases the vector's</span>
<span class="lnr">167 </span><span class="Comment">   physical length, but does not change its logical size. I guess this is</span>
<span class="lnr">168 </span><span class="Comment">   consistent with the fact that Vec.set automatically increases the vector's</span>
<span class="lnr">169 </span><span class="Comment">   logical size. Vec.grow_to_by_double is replaced by vector::resize here. *)</span>
<span class="lnr">170 </span>
<span class="lnr">171 </span><span class="Comment">(*</span>
<span class="lnr">172 </span><span class="Comment">  Local Variables:</span>
<span class="lnr">173 </span><span class="Comment">  compile-command: &quot;../mezzo vector.mz&quot;</span>
<span class="lnr">174 </span><span class="Comment">  End:</span>
<span class="lnr">175 </span><span class="Comment">*)</span>
</pre>
</body>
</html>
