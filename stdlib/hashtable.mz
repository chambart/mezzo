(* -------------------------------------------------------------------------- *)

(* A bucket is a mutable list of entries. Each entry holds a key and a value. *)

mutable data bucket k a =
  | Nil
  | Cons { key: k; value: a; tail: bucket k a }

(* Iteration over a bucket. Each entry is presented in turn to the function
   [f]. Note that the entries that are presented to [f] are detached, i.e.,
   their [tail] field is garbage. *)

val rec iter_bucket_down [k, a, p : perm] (
  consumes b: bucket k a,
  f: (consumes b: Cons { key: k; value: a; tail: unknown } | p) -> ()
  | p
) : () =
  match b with
  | Nil ->
      ()
  | Cons ->
      (* Iteration from the end down to the beginning of the list. *)
      iter_bucket_down (b.tail, f);
      f b
  end

(* -------------------------------------------------------------------------- *)

(* The definition of a hash table. *)

mutable data table k a =
  Table {
    (* The table's current number of elements. *)
    cardinal: int;
    (* The bucket array, whose length is always a power of 2. *)
    buckets: array::array (bucket k a);
    (* The hash function. *)
    hash: k -> int;
    (* The equality function. *)
    equal: (k, k) -> bool
  }

(* -------------------------------------------------------------------------- *)

(* Internal functions. *)

(* [key_index] computes the array index that corresponds to the key [x]. *)

(* The type assigned to [key_index] is much more complex than I would like:
   we have been forced to expand the permission [t @ table k a] and assign
   the name [buckets] to the value contained in the [buckets] field of [t].
   This allows us to express the fact that [t.buckets] is *not* modified by
   [key_index]. This fact, in turn, is required in order to type-check some
   clients. If we wrote just [t @ table k a], we would know that [t] remains
   a table, but we would not know that [t.buckets] is unmodified, so a client
   that reads [t.buckets] *before* invoking [key_index] and uses this value
   *after* invoking [key_index] would be ill-typed. *)

val key_index [k, a, buckets : term] (
  t: Table { cardinal: int; buckets = buckets; hash: k -> int; equal: (k, k) -> bool },
  x: k
  | buckets @ array::array (bucket k a)
) : int =
  t.hash x & (array::length t.buckets - 1)

(* [push] inserts a detached entry, which contains a valid key-value pair,
   into the bucket at index [i] in the [buckets] array. *)
(* TEMPORARY if push/key_index always used together, push could be modified *)

val push [k, a] (
  buckets: array::array (bucket k a),
  i: int,
  consumes entry: Cons { key: k; value: a; tail: unknown }
) : () =
  array::update
    (* A horrid explicit type application. *)
    [bucket k a, (entry @ Cons { key: k; value: a; tail: unknown }), empty]
    (* A horrid explicit function header. *)
    (buckets, i, fun (consumes b: bucket k a | consumes entry @ Cons { key: k; value: a; tail: unknown }) : bucket k a =
      entry.tail <- b;
      entry
    )

(* TEMPORARY we need the following loop over arrays, which I am afraid
   must be primitive, because the loop invariant involves a partially
   consumed array. *)

val consume_up [a, p : perm] (
  consumes x: array::array a,
  f: (int, consumes a | p) -> ()
  | p
) : () =
  fail (* TEMPORARY move to array.mzi *)

(* [resize] doubles the size of the hash table. A new buckets array is allocated.
   The existing entries are re-used: they are not re-allocated. *)

val resize [k, a] (t: table k a) : () =
  let old_buckets = t.buckets in
  let new_size = array::length old_buckets * 2 in
  if new_size < array::max_length then begin
    (* Update [t.buckets] immediately, so that [key_index] sees the new
       bucket count. *)
    t.buckets <- array::init (new_size, fun (i: int) : bucket k a = Nil);
    (* The array [old_buckets] is consumed by the following loop. This allows
       us to grab the entries that we find in it and move them (without copy)
       to the new array [t.buckets]. *)
    consume_up (old_buckets, fun (old_index: int, consumes b : bucket k a | t @ table k a) : () =
      iter_bucket_down (b, fun (consumes b: Cons { key: k; value: a; tail: unknown } | t @ table k a) : () =
	push [k, a] (t.buckets, key_index [k, a] (t, b.key), b)
	(* BUG? the line above fails if I omit any of the type applications *)
      )
    )
  end

(* [power_2_above] computes the first power of 2 that lies above [x] and [n],
   where [x] is itself a power of 2. It stops when the maximum array length
   is exceeded. *)

val rec power_2_above (x: int, n: int) : int =
  if x >= n then x
  else if x * 2 > array::max_length then x
  else power_2_above (x * 2, n)

(* [create_buckets] rounds up its [capacity] argument to the nearest power of
   2 above [n], then allocates a new bucket array. *)

val create_buckets [k, a] (capacity: int) : array::array (bucket k a) =
  array::init (power_2_above (16, capacity), fun (i: int) : bucket k a = Nil)

(* -------------------------------------------------------------------------- *)

(* Creation. *)

val create [k, a] (capacity: int, hash: k -> int, equal: (k, k) -> bool) : table k a =
  Table {
    cardinal = 0;
    buckets = create_buckets [k, a] capacity;
      (* BUG? if I omit the above type application, the type-checker fails to
	 instantiate the universal type *)
    hash = hash;
    equal = equal
  }

(* -------------------------------------------------------------------------- *)

(* Clearing. *)

val clear [k, a] (t: table k a) : () =
  t.cardinal <- 0;
  arrayops::reset (t.buckets, fun (i: int) : bucket k a = Nil)

val reset [k, a] (t: table k a, capacity: int) : () =
  t.cardinal <- 0;
  t.buckets <- create_buckets [k, a] capacity

(* -------------------------------------------------------------------------- *)

(* Insertion. *)

val add [k, a] (consumes x: k, consumes v: a, t: table k a) : () =
  push [k, a] (t.buckets, key_index [k, a] (t, x), Cons { key = x; value = v; tail = () });
  t.cardinal <- t.cardinal + 1;
  if t.cardinal > 2 * array::length t.buckets then
    resize [k, a] t
    (* BUG? the line above fails if I omit the type application *)

(* -------------------------------------------------------------------------- *)

(* Removal. *)

val remove [k, a] (x: k, t: table k a) : () =
  let rec remove (consumes b: bucket k a | t @ table k a * x @ k) : bucket k a =
    match b with
    | Nil ->
        b
    | Cons { key; value; tail } ->
        if t.equal (key, x) then begin
          t.cardinal <- t.cardinal - 1;
	  tail
	end
        else begin
	  b.tail <- remove tail;
	  b
	end
    end
  in
  array::update
    (* [bucket k a, (t @ table k a * x @ k), (t @ table k a * x @ k)] *)
    (t.buckets, key_index [k, a] (t, x), remove)

  (* BUG? this version of [remove] is accepted, even though I think it should be
     rejected: the call to [array::update] requires [t.buckets @ array (...)] AND
     [t @ table k a], which cannot be simultaneously satisfied. Strangely enough,
     if I uncomment the type application, then the type-checker rejects the code
     (which seems to be the desired behavior). *)

(* -------------------------------------------------------------------------- *)

(* Lookup. *)
(*
val find [k, a] duplicable a => (x: k, t: table k a) : option a =
  let equal = t.equal in
  let rec find (b: bucket k a | x @ k) : option a =
    match b with
    | Nil ->
        none
    | Cons ->
        if equal (x, b.key) then
	  some b.value
	else
	  find b.tail
    end
  in
  find (array::get(t.buckets, key_index (t, x)))
*)
(*
Local Variables:
compile-command: "../mezzo hashtable.mz"
End:
*)
