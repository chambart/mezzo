open bucket
(* TEMPORARY ultimately, might wish not to open bucket *)

(* -------------------------------------------------------------------------- *)

(* The definition of a hash table. *)

mutable data table k a =
  Table {
    (* The table's current number of elements. *)
    cardinal: int;
    (* The bucket array, whose length is always a power of 2. *)
    buckets: array (bucket k a);
    (* The hash function. *)
    hash: k -> int;
    (* The equality function. *)
    equal: (k, k) -> bool
  }

(* -------------------------------------------------------------------------- *)

(* Internal functions. *)

(* [key_index] computes the array index that corresponds to the key [x]. *)

(* The type assigned to [key_index] is much more complex than I would like:
   we have been forced to expand the permission [t @ table k a] and assign
   the name [buckets] to the value contained in the [buckets] field of [t].
   This allows us to express the fact that [t.buckets] is *not* modified by
   [key_index]. This fact, in turn, is required in order to type-check some
   clients. If we wrote just [t @ table k a], we would know that [t] remains
   a table, but we would not know that [t.buckets] is unmodified, so a client
   that reads [t.buckets] *before* invoking [key_index] and uses this value
   *after* invoking [key_index] would be ill-typed. *)

val key_index [k, a, buckets : term] (
  t: Table { cardinal: int; buckets = buckets; hash: k -> int; equal: (k, k) -> bool },
  x: k
  | buckets @ array (bucket k a)
) : int =
  t.hash x & (array::length t.buckets - 1)

(* [push] inserts a detached entry, which contains a valid key-value pair,
   into the bucket at index [i] in the [buckets] array. *)
(* TEMPORARY if push/key_index always used together, push could be modified *)

val push [k, a] (
  buckets: array (bucket k a),
  i: int,
  consumes entry: BCons { key: k; value: a; tail: unknown }
) : () =
  array::update
    (buckets, i, fun (consumes b: bucket k a | consumes entry @ BCons { key: k; value: a; tail: unknown }) : bucket k a =
      entry.tail <- b;
      entry
    )

(* TEMPORARY we need the following loop over arrays, which I am afraid
   must be primitive, because the loop invariant involves a partially
   consumed array. *)

val consume_up [a, p : perm] (
  consumes x: array a,
  f: (int, consumes a | p) -> ()
  | p
) : () =
  fail (* TEMPORARY move to array.mzi *)

(* [resize] doubles the size of the hash table. A new buckets array is allocated.
   The existing entries are re-used: they are not re-allocated. *)

val resize [k, a] (t: table k a) : () =
  let old_buckets = t.buckets in
  let new_size = array::length old_buckets * 2 in
  if new_size < array::max_length then begin
    (* Update [t.buckets] immediately, so that [key_index] sees the new
       bucket count. *)
    t.buckets <- array::init (new_size, fun (i: int) : bucket k a = BNil);
    (* The array [old_buckets] is consumed by the following loop. This allows
       us to grab the entries that we find in it and move them (without copy)
       to the new array [t.buckets]. *)
    consume_up (old_buckets, fun (old_index: int, consumes b : bucket k a | t @ table k a) : () =
      iter_bucket_down (b, fun (consumes b: BCons { key: k; value: a; tail: unknown } | t @ table k a) : () =
	push (t.buckets, key_index [k, a] (t, b.key), b)
      )
    )
  end

(* TEMPORARY add an operation that fuses two hash tables (i.e. destructively
   merges one into the other). It would look at lot like resize (twice). *)

(* [power_2_above] computes the first power of 2 that lies above [x] and [n],
   where [x] is itself a power of 2. It stops when the maximum array length
   is exceeded. *)

val rec power_2_above (x: int, n: int) : int =
  if x >= n then x
  else if x * 2 > array::max_length then x
  else power_2_above (x * 2, n)

(* [create_buckets] rounds up its [capacity] argument to the nearest power of
   2 above [n], then allocates a new bucket array. *)

val create_buckets [k, a] (capacity: int) : array (bucket k a) =
  array::init (power_2_above (16, capacity), fun (i: int) : bucket k a = BNil)

(* -------------------------------------------------------------------------- *)

(* Creation. *)

val create [k, a] (capacity: int, hash: k -> int, equal: (k, k) -> bool) : table k a =
  Table {
    cardinal = 0;
    buckets = create_buckets capacity;
    hash = hash;
    equal = equal
  }

(* -------------------------------------------------------------------------- *)

(* Clearing. *)

val clear [k, a] (t: table k a) : () =
  t.cardinal <- 0;
  arrayops::reset (t.buckets, fun (i: int) : bucket k a = BNil)

val reset [k, a] (t: table k a, capacity: int) : () =
  t.cardinal <- 0;
  t.buckets <- create_buckets capacity

(* -------------------------------------------------------------------------- *)

(* Insertion. *)

val add [k, a] (consumes x: k, consumes v: a, t: table k a) : () =
  push (t.buckets, key_index [k, a] (t, x), BCons { key = x; value = v; tail = () });
  t.cardinal <- t.cardinal + 1;
  if t.cardinal > 2 * array::length t.buckets then
    resize t

(* -------------------------------------------------------------------------- *)

(* Removal. *)

(* In an earlier version of this code, instead of using an auxiliary reference
   cell [found], we updated [t.cardinal] directly inside the function
   [ok]. Type-checking this version of the code was more tricky, because [ok]
   needed read/write access to [t.cardinal] at a moment when the ownership of
   [t.buckets] had been taken away from [t] by [array::update]. This forced
   [ok] to request (and preserve) a precise description of [t], so that the
   type system could tell that [ok] did not modify the field [t.buckets]. *)

val remove [k, a] (x: k, t: table k a) : option a =

  let equal = t.equal in

  (* Define an [ok] predicate that can be passed to [bucket::remove]. *)
  let ok (key: k | x @ k) : bool =
    equal (key, x)
  in

  (* Allocate a reference to store the second result of [bucket::remove]. *)
  let r = newref none in

  (* Partially apply [bucket::remove] to [ok]. Arrange for the second
     result of [bucket::remove] to be stored in [r], so [remove] returns
     just one result and is a suitable argument for [array::update]. *)
  let remove (consumes b: bucket k a | x @ k * r @ ref (option a)) : bucket k a =
    let b, v = bucket::remove (b, ok) in
    r := v;
    b
  in

  (* Apply [remove] at the desired array index. *)
  array::update
    [post = (x @ k * r @ ref (option a))] (* WISH get rid of this *)
    (t.buckets, key_index [k, a] (t, x), remove);

  (* If the desired entry has been found and removed, update the table's
     cardinal. Then, return the value that was removed. *)
  if !r then
    t.cardinal <- t.cardinal - 1;
  !r

(* TEMPORARY we need also [remove_all]? does ocaml offer it? *)

(* -------------------------------------------------------------------------- *)

(* Lookup. *)

val mem [k, a] (x: k, t: table k a) : bool =
  let equal = t.equal in
  array::consult
    [b = (bool | x @ k)]
    (* WISH could we get rid of this type application? *)
    (t.buckets, key_index [k, a] (t, x), fun (b: bucket k a | x @ k) : bool =
      bucket::mem (equal, x, b)
    )

(* We first define an internal version of [find] which locates the appropriate
   bucket and passes it to a function [f]. *)

val internal_find [k, a, answer] duplicable a => (
  f: (bucket k a | x @ k) -> answer,
  x: k,
  t: table k a
) : answer =
  (* We use [array::consult] instead of [array::get] because [k] is not
     duplicable. *)
  array::consult
    [pre = (x @ k), b = (answer | x @ k)] (* WISH get rid of this *)
    (t.buckets, key_index [k, a] (t, x), f)

(* By instantiating [f] with a function that stops at the first match,
   we obtain [find]. *)

val find [k, a] duplicable a => (x: k, t: table k a) : option a =
  let equal = t.equal in
  let rec f (b: bucket k a | x @ k) : option a =
    match b with
    | BNil ->
        none
    | BCons ->
        if equal (x, b.key) then some b.value else f b.tail
    end
  in
  internal_find (f, x, t)

(* By instantiating [f] with a function that searches for all matches,
   we obtain [find_all]. *)

val find_all [k, a] duplicable a => (x: k, t: table k a) : list::list a =
  let equal = t.equal in
  let rec f (b: bucket k a | x @ k) : list::list a =
    match b with
    | BNil ->
        list::nil
    | BCons ->
        if equal (x, b.key) then list::cons (b.value, f b.tail) else f b.tail
    end
  in
  internal_find (f, x, t)

(* TEMPORARY use [bucket::find] and [bucket::find_all] (must wait until
   duplicable constraints can appear in .mzi) *)

(* -------------------------------------------------------------------------- *)

(* Update. *)

(* [update (t, x, f)] looks for the key [x] in the table [t]. It calls the
   user-supplied function [f] exactly once, and passes it either the value [v]
   that is associated with the key [x], or nothing, if the key [x] does not
   appear in the table. The function [f] returns either a new value, or
   nothing. In the former case, the new value replaces the value [v]. In the
   latter case, the key [x] is removed (if it was there at all). *)

val option_cardinal [a] (o: option a) : int =
  match o with
  | None -> 0
  | Some -> 1
  end

val update [k, a, pre : perm, post : perm] (
  t: table k a,
  consumes x: k,
  f: (consumes (option a | pre)) -> (option a | post)
  | consumes pre
) : (| post) =

  (* Wrap [f] so as to record the increase or decrease in the table's cardinal. *)
  let delta = newref () in
  let f (consumes ov: option a | consumes (pre * delta @ ref ())) :
        (option a | post * delta @ ref int) =
    let decrease = option_cardinal ov in
    let ov = f ov in
    let increase = option_cardinal ov in
    delta := increase - decrease;
    ov
  in

  (* Adapt [bucket::update]. *)
  let equal = t.equal in
  let update (consumes b: bucket k a | consumes (x @ k * pre * delta @ ref ())) : (bucket k a | post * delta @ ref int) =
    bucket::update [post = (post * delta @ ref int)] (equal, b, x, f)
    (* WISH could we get rid of this type application? without it, I get an error *)
  in

  (* Call [array::update]. *)
  array::update [post = (post * delta @ ref int)]
    (t.buckets, key_index [k, a] (t, x), update);
    (* WISH could we get rid of this type application?
       without it, the call to array::update succeeds
       but we lose the permission for [delta] and the cardinal update (below) fails *)

  (* Update the table's cardinal. *)
  t.cardinal <- t.cardinal + !delta

(* -------------------------------------------------------------------------- *)

(* Iteration. *)

(* For simplicity, we assign [fold] a type that does not allow performing a
   strong update on the keys or values. If we used a primitive operation on
   arrays that allows performing a strong update on an array, then we could
   do better. TEMPORARY *)

val fold [k, a, b] (
  t: table k a,
  consumes seed: b,
  f: (k, a, consumes b) -> b
) : b =
  arrayops::fold_up (t.buckets, seed, fun (bck: bucket k a, consumes accu: b) : b =
    bucket::fold (bck, accu, f)
  )

val iter [k, a, p : perm] (
  t: table k a,
  f: (k, a | p) -> ()
  | p
) : () =
  fold [b=(| p)] (t, (), fun (x: k, v: a, (| p)) : () =
    f (x, v)
  )
  (* WISH could we get rid of this type application? *)

(* -------------------------------------------------------------------------- *)

(* Statistics. *)

val cardinal [k, a] (t: table k a) : int =
  t.cardinal

data statistics = Statistics {
  num_bindings: int;
  num_buckets: int;
  max_bucket_length: int;
  bucket_histogram: array int
}

val stats [k, a] (t: table k a) : statistics =
  (* Compute the maximum bucket length. *)
  let mbl =
    arrayops::fold_up (t.buckets, 0, fun (b: bucket k a, accu: int) : int =
      max (bucket::length b, accu)
    )
  in
  (* Build a histogram, which maps bucket lengths to bucket counts. *)
  let histo = array::create (mbl + 1, 0) in
  arrayops::iter_up (t.buckets, fun (b: bucket k a | histo @ array int) : () =
    let l = bucket::length b in
    array::set (histo, l, array::get (histo, l) + 1)
  );
  (* Return a statistics record. *)
  Statistics {
    num_bindings = t.cardinal;
    num_buckets  = array::length t.buckets;
    max_bucket_length = mbl;
    bucket_histogram = histo
  }

(*
  Local Variables:
  compile-command: "../mezzo hashtable.mz"
  End:
*)
