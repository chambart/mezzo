open bucket
(* TEMPORARY ultimately, might wish not to open bucket *)

(* -------------------------------------------------------------------------- *)

(* The definition of a hash table. *)

mutable data table k a =
  Table {
    (* The table's current number of elements. *)
    cardinal: int;
    (* The bucket array, whose length is always a power of 2. *)
    buckets: array::array (bucket k a);
    (* The hash function. *)
    hash: k -> int;
    (* The equality function. *)
    equal: (k, k) -> bool
  }

(* -------------------------------------------------------------------------- *)

(* Internal functions. *)

(* [key_index] computes the array index that corresponds to the key [x]. *)

(* The type assigned to [key_index] is much more complex than I would like:
   we have been forced to expand the permission [t @ table k a] and assign
   the name [buckets] to the value contained in the [buckets] field of [t].
   This allows us to express the fact that [t.buckets] is *not* modified by
   [key_index]. This fact, in turn, is required in order to type-check some
   clients. If we wrote just [t @ table k a], we would know that [t] remains
   a table, but we would not know that [t.buckets] is unmodified, so a client
   that reads [t.buckets] *before* invoking [key_index] and uses this value
   *after* invoking [key_index] would be ill-typed. *)

val key_index [k, a, buckets : term] (
  t: Table { cardinal: int; buckets = buckets; hash: k -> int; equal: (k, k) -> bool },
  x: k
  | buckets @ array::array (bucket k a)
) : int =
  t.hash x & (array::length t.buckets - 1)

(* [push] inserts a detached entry, which contains a valid key-value pair,
   into the bucket at index [i] in the [buckets] array. *)
(* TEMPORARY if push/key_index always used together, push could be modified *)

val push [k, a] (
  buckets: array::array (bucket k a),
  i: int,
  consumes entry: BCons { key: k; value: a; tail: unknown }
) : () =
  array::update
    [consumed = (entry @ BCons { key: k; value: a; tail: unknown })]
    (buckets, i, fun (consumes b: bucket k a | consumes entry @ BCons { key: k; value: a; tail: unknown }) : bucket k a =
      entry.tail <- b;
      entry
    )

(* TEMPORARY we need the following loop over arrays, which I am afraid
   must be primitive, because the loop invariant involves a partially
   consumed array. *)

val consume_up [a, p : perm] (
  consumes x: array::array a,
  f: (int, consumes a | p) -> ()
  | p
) : () =
  fail (* TEMPORARY move to array.mzi *)

(* [resize] doubles the size of the hash table. A new buckets array is allocated.
   The existing entries are re-used: they are not re-allocated. *)

val resize [k, a] (t: table k a) : () =
  let old_buckets = t.buckets in
  let new_size = array::length old_buckets * 2 in
  if new_size < array::max_length then begin
    (* Update [t.buckets] immediately, so that [key_index] sees the new
       bucket count. *)
    t.buckets <- array::init (new_size, fun (i: int) : bucket k a = BNil);
    (* The array [old_buckets] is consumed by the following loop. This allows
       us to grab the entries that we find in it and move them (without copy)
       to the new array [t.buckets]. *)
    consume_up (old_buckets, fun (old_index: int, consumes b : bucket k a | t @ table k a) : () =
      iter_bucket_down (b, fun (consumes b: BCons { key: k; value: a; tail: unknown } | t @ table k a) : () =
	push [k, a] (t.buckets, key_index [k, a] (t, b.key), b)
	(* BUG? the line above fails if I omit any of the type applications *)
      )
    )
  end

(* [power_2_above] computes the first power of 2 that lies above [x] and [n],
   where [x] is itself a power of 2. It stops when the maximum array length
   is exceeded. *)

val rec power_2_above (x: int, n: int) : int =
  if x >= n then x
  else if x * 2 > array::max_length then x
  else power_2_above (x * 2, n)

(* [create_buckets] rounds up its [capacity] argument to the nearest power of
   2 above [n], then allocates a new bucket array. *)

val create_buckets [k, a] (capacity: int) : array::array (bucket k a) =
  array::init (power_2_above (16, capacity), fun (i: int) : bucket k a = BNil)

(* -------------------------------------------------------------------------- *)

(* Creation. *)

val create [k, a] (capacity: int, hash: k -> int, equal: (k, k) -> bool) : table k a =
  Table {
    cardinal = 0;
    buckets = create_buckets [k, a] capacity;
      (* BUG? if I omit the above type application, the type-checker fails to
	 instantiate the universal type *)
    hash = hash;
    equal = equal
  }

(* -------------------------------------------------------------------------- *)

(* Clearing. *)

val clear [k, a] (t: table k a) : () =
  t.cardinal <- 0;
  arrayops::reset (t.buckets, fun (i: int) : bucket k a = BNil)

val reset [k, a] (t: table k a, capacity: int) : () =
  t.cardinal <- 0;
  t.buckets <- create_buckets [k, a] capacity

(* -------------------------------------------------------------------------- *)

(* Insertion. *)

val add [k, a] (consumes x: k, consumes v: a, t: table k a) : () =
  push [k, a] (t.buckets, key_index [k, a] (t, x), BCons { key = x; value = v; tail = () });
  t.cardinal <- t.cardinal + 1;
  if t.cardinal > 2 * array::length t.buckets then
    resize [k, a] t
    (* BUG? the line above fails if I omit the type application *)

(* -------------------------------------------------------------------------- *)

(* Removal. *)

(* In an earlier version of this code, instead of using an auxiliary reference
   cell [found], we updated [t.cardinal] directly inside the function
   [ok]. Type-checking this version of the code was more tricky, because [ok]
   needed read/write access to [t.cardinal] at a moment when the ownership of
   [t.buckets] had been taken away from [t] by [array::update]. This forced
   [ok] to request (and preserve) a precise description of [t], so that the
   type system could tell that [ok] did not modify the field [t.buckets]. *)

val remove [k, a] (x: k, t: table k a) : option a =

  let equal = t.equal in

  (* Define an [ok] predicate that can be passed to [bucket::remove]. *)
  let ok (key: k | x @ k) : bool =
    equal (key, x)
  in

  (* Allocate a reference to store the second result of [bucket::remove]. *)
  let r = newref none in

  (* Partially apply [bucket::remove] to [ok]. Arrange for the second
     result of [bucket::remove] to be stored in [r], so [remove] returns
     just one result and is a suitable argument for [array::update]. *)
  let remove (consumes b: bucket k a | x @ k * r @ ref (option a)) : bucket k a =
    let b, v = bucket::remove (b, ok) in
    r := v;
    b
  in

  (* Apply [remove] at the desired array index. *)
  array::update
    [consumed = empty]
    (t.buckets, key_index [k, a] (t, x), remove);

  (* If the desired entry has been found and removed, update the table's
     cardinal. Then, return the value that was removed. *)
  if !r then begin
    t.cardinal <- t.cardinal - 1;
    !r
  end
  else
    !r
  (* BUG? if I write just
     if !r then t.cardinal <- t.cardinal - 1; !r
     (thus factorizing the expression !r)
     then the merge seems to fail and the code does not type-check *)

(* TEMPORARY we need also [remove_all]? does ocaml offer it? *)

(* -------------------------------------------------------------------------- *)

(* Lookup. *)

(* We first define an internal version of [find] which locates the appropriate
   bucket and passes it to a function [f]. *)

val internal_find [k, a, answer] duplicable a => (
  f: (bucket k a | x @ k) -> answer,
  x: k,
  t: table k a
) : answer =
  (* We use [array::consult] instead of [array::get] because [k] is not
     duplicable. *)
  array::consult
    [preserved = (x @ k)]
    (t.buckets, key_index [k, a] (t, x), f)

(* By instantiating [f] with a function that stops at the first match,
   we obtain [find]. *)

val find [k, a] duplicable a => (x: k, t: table k a) : option a =
  let equal = t.equal in
  let rec f (b: bucket k a | x @ k) : option a =
    match b with
    | BNil ->
        none
    | BCons ->
        if equal (x, b.key) then some b.value else f b.tail
    end
  in
  internal_find (f, x, t)

(* By instantiating [f] with a function that searches for all matches,
   we obtain [find_all]. *)

val find_all [k, a] duplicable a => (x: k, t: table k a) : list::list a =
  let equal = t.equal in
  let rec f (b: bucket k a | x @ k) : list::list a =
    match b with
    | BNil ->
        list::nil
    | BCons ->
        if equal (x, b.key) then list::cons (b.value, f b.tail) else f b.tail
    end
  in
  internal_find (f, x, t)

(* TEMPORARY use [bucket::find] and [bucket::find_all] (must wait until
   duplicable constraints can appear in .mzi) *)

(*
Local Variables:
compile-command: "../mezzo hashtable.mz"
End:
*)
