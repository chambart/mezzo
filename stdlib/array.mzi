(* The primitive operations on arrays. *)

(* TEMPORARY ocaml distinguishes append_prim and append; also, it distinguishes
   between unsafe_foo and foo. Clarify. *)

(* -------------------------------------------------------------------------- *)

(* TEMPORARY I would like to write something like this:

(* We wish to distinguish mutable and immutable arrays, so the type
   of arrays takes the form [array m a], where the phantom parameter
   [m] is intended to be either [ro] or [rw]. The type parameter [a]
   represents the type of the elements of the array. It is always a
   duplicable type. *)

abstract ro
fact duplicable ro

abstract rw

abstract array m a
fact duplicable m => duplicable (array m a)

*)

(* TEMPORARY for the time being, arrays are mutable. *)

abstract array a
fact exclusive (array a)

(* The type [a] of the array elements need not be duplicable. However, some
   operations, such as [get], require [a] to be duplicable. When [a] is not
   duplicable, one must work without [get]. A few other functions, such as
   [swap] and [update], do not require [a] to be duplicable. *)

(* -------------------------------------------------------------------------- *)

(* Initialization. *)

(* [create] creates a new array and fills it with an initial value. It requires
   the element type [a] to be duplicable. *)

val create : [a] (* TEMPORARY duplicable a => *) (int, a) -> array a

(* [init] creates a new array and uses a user-supplied function [f] to fill it.
   It does not require the element type [a] to be duplicable. *)

val init : [a, p : perm] (
  n: int,
  f: (int | p) -> a
  | p) -> array a

(* -------------------------------------------------------------------------- *)

(* Access. *)

val get    : [a] (* TEMPORARY duplicable a => *) (array a, int) -> a
val set    : [a] (array a, int, consumes a) -> ()
val swap   : [a] (array a, int, int) -> ()

(* [consult] is a particular use of [get], with delimited scope, that does
   not require the element type to be duplicable. The function [f] does not
   have access to the array, so using [consult] instead of [get] is a way
   of ensuring that we only read one element at a time (and give it back). *)

(* A drawback of this approach is that the user has to work in what resembles
   CPS style. Could we somehow impose the same discipline and obtain the same
   effect in direct style? *)

val consult : [a, preserved : perm, consumed : perm, b] (
  array a, int,
  f: (a | preserved * consumes consumed) -> b
  | preserved * consumes consumed
) -> b

val consult_variant : [a, pre : perm, b] (
  array a, int,
  f: (a | consumes pre) -> b
  | consumes pre
) -> b

(* [update] is a particular combination of [get] and [set] that does not
   require the element type to be duplicable. *)

(* TEMPORARY since [f] is called exactly once, a [pre/post] pair would be
   more precise/expressive than a [preserved/consumed] pair; but less
   convenient?
   
   jonathan: switching to a [pre/post] pair saves one explicit type application
   in [hashtable.mz]... not sure it's worth changing it to something more
   sophisticated *)

val update : [a, preserved : perm, consumed : perm] (
  array a, int,
  f: (consumes a | preserved * consumes consumed) -> a
  | preserved * consumes consumed
) -> ()

val update_variant : [a, pre : perm, post : perm] (
  array a, int,
  f: (consumes a | consumes pre) -> (a | post)
  | consumes pre
) -> (| post)

(* -------------------------------------------------------------------------- *)

(* Length. *)

val max_length : int
val length : [a] array a -> int

(* -------------------------------------------------------------------------- *)

(* Blitting. *)

(* TEMPORARY we would like two version of [sub]: one that requires [duplicable a]
   and does not consume the original array; and one that does not require
   [duplicable a] and consumes the original array. Because arrays are mutable,
   neither of these two version is better than hthe other. Same problem with the
   other blitting functions below. *)

(* TEMPORARY add [duplicable a =>] to each function below *)

val sub    : [a] (array a, int, int)  -> array a
val append : [a] (array a, array a)   -> array a
val concat : [a] list::list (array a) -> array a
val blit   : [a] (a1: array a, ofs1: int, a2: array a, ofs2: int, len: int) -> ()

(* TEMPORARY add an operation that allows performing a strong
   update over an array *)

