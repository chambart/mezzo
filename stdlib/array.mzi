(* The primitive operations on arrays. *)

(* TEMPORARY ocaml distinguishes append_prim and append; also, it distinguishes
   between unsafe_foo and foo. Clarify. *)

(* -------------------------------------------------------------------------- *)

(* TEMPORARY I would like to write something like this:

(* We wish to distinguish mutable and immutable arrays, so the type
   of arrays takes the form [array m a], where the phantom parameter
   [m] is intended to be either [ro] or [rw]. The type parameter [a]
   represents the type of the elements of the array. It is always a
   duplicable type. *)

abstract ro
fact duplicable ro

abstract rw

abstract array m a
fact duplicable m => duplicable (array m a)

*)

(* TEMPORARY for the time being, arrays are mutable. *)

abstract array a
fact exclusive (array a)

(* The type [a] of the array elements need not be duplicable. However, some
   operations, such as [get], require [a] to be duplicable. When [a] is not
   duplicable, one must work without [get]. A few other functions, such as
   [swap] and [update], do not require [a] to be duplicable. *)

(* -------------------------------------------------------------------------- *)

(* Initialization. *)

(* [create] creates a new array and fills it with an initial value. It requires
   the element type [a] to be duplicable. *)

val create : [a] duplicable a => (int, a) -> array a

(* [init] creates a new array and uses a user-supplied function [f] to fill it.
   It does not require the element type [a] to be duplicable. *)

val init : [a, p : perm] (
  n: int,
  f: (int | p) -> a
  | p) -> array a

(* -------------------------------------------------------------------------- *)

(* Access. *)

val get    : [a] duplicable a => (array a, int) -> a
val set    : [a] (array a, int, consumes a) -> ()
val swap   : [a] (array a, int, int) -> ()

(* [consult] is a particular use of [get], with delimited scope, that does
   not require the element type to be duplicable. The function [f] does not
   have access to the array, so using [consult] instead of [get] is a way
   of ensuring that we only read one element at a time (and give it back). *)

(* The type of [consult] advertises the fact that [consult] invokes [f]
   exactly once. Indeed, [f] is invoked at least once, otherwise [consult]
   would not be able to produce an element of type [b]. And [f] is invoked
   at most once, because [f] requires and consumes the permission [pre],
   which is not duplicable. *)

(* A drawback of this approach is that the user has to work in what resembles
   CPS style. Could we somehow impose the same discipline and obtain the same
   effect in direct style? *)

val consult : [a, pre : perm, b] (
  array a, int,
  f: (a | consumes pre) -> b
  | consumes pre
) -> b

(* [update] is a particular combination of [get] and [set] that does not
   require the element type to be duplicable. *)

(* The type of [update] advertises the fact that [update] invokes [f]
   exactly once. *)

val update : [a, pre : perm, post : perm] (
  array a, int,
  f: (consumes a | consumes pre) -> (a | post)
  | consumes pre
) -> (| post)

(* -------------------------------------------------------------------------- *)

(* Length. *)

val max_length : int
val length : [a] array a -> int

(* -------------------------------------------------------------------------- *)

(* Blitting. *)

(* TEMPORARY we would like two version of [sub]: one that requires [duplicable a]
   and does not consume the original array; and one that does not require
   [duplicable a] and consumes the original array. Because arrays are mutable,
   neither of these two version is better than hthe other. Same problem with the
   other blitting functions below. *)

val sub    : [a] duplicable a => (array a, int, int)  -> array a
val append : [a] duplicable a => (array a, array a)   -> array a
val concat : [a] duplicable a => list::list (array a) -> array a
val blit   : [a] duplicable a => (a1: array a, ofs1: int, a2: array a, ofs2: int, len: int) -> ()

(* TEMPORARY add an operation that allows performing a strong
   update over an array *)

