open array

(* Operations on arrays. *)

(* -------------------------------------------------------------------------- *)

(* Generic loops over a segment of an array. *)

(* We use semi-open intervals of the form [i, j). That is, the index [i] is
   part of the interval, and the index [j] is not part of it. The interval
   is non-empty if and only if [i < j] holds. *)

val fold_segment_up   : [a] (
  i: int, j: int, consumes accu: a,
  f: (int, consumes a) -> a
) -> a

val fold_segment_down : [a] (
  i: int, j: int, consumes accu: a,
  f: (int, consumes a) -> a
) -> a

val iter_segment_up   : [p : perm] (
  i: int, j: int,
  f: (int | p) -> ()
  | p) -> ()

val iter_segment_down : [p : perm] (
  i: int, j: int,
  f: (int | p) -> ()
  | p) -> ()

(* Generic loops over an entire array. *)

val fold_array_up   : [a, b] (
  x: array a, consumes seed: b,
  f: (int, consumes b | x @ array a) -> b
) -> b

val fold_array_down : [a, b] (
  x: array a, consumes seed: b,
  f: (int, consumes b | x @ array a) -> b
) -> b

val iter_array_up   : [a, p : perm] (
  x: array a,
  f: (int | x @ array a * p) -> ()
  | p) -> ()

val iter_array_down : [a, p : perm] (
  x: array a,
  f: (int | x @ array a * p) -> ()
  | p) -> ()

(* A variant of the above loops, where [f] receives not only an index [i],
   but also the corresponding array element. *)

(* Because the type [a] is not assumed duplicable, getting hold of the
   element temporarily invalidates the array, which implies that [f]
   cannot receive the permission [x @ array a]. This is unfortunate.
   We could offer a variant of this function where [a] is assumed
   duplicable and [f] receives this permission. (This also suggests
   that conditional permissions, of the form (duplicable a => p),
   might be useful! TEMPORARY *)

val foldi_up   : [a, b] (
  x: array a,
  consumes seed: b,
  f: (int, a, consumes accu: b) -> b
) -> b

val foldi_down : [a, b] (
  x: array a,
  consumes seed: b,
  f: (int, a, consumes accu: b) -> b
) -> b

val iteri_up   : [a, p : perm] (
  x: array a,
  f: (int, a | p) -> ()
  | p) -> ()

val iteri_down : [a, p : perm] (
  x: array a,
  f: (int, a | p) -> ()
  | p) -> ()

(* A degenerate variant of the above loops, where the function [f] has
   access to the element, but not the index [i] or the array [x]. *)

val fold_up   : [a, b] (
  x: array a,
  consumes seed: b,
  f: (a, consumes accu: b) -> b
) -> b

val fold_down : [a, b] (
  x: array a,
  consumes seed: b,
  f: (a, consumes accu: b) -> b
) -> b

val iter_up   : [a, p : perm] (
  x: array a,
  f: (a | p) -> ()
  | p) -> ()

val iter_down : [a, p : perm] (
  x: array a,
  f: (a | p) -> ()
  | p) -> ()

(* TEMPORARY it would be interesting to offer a loop form where [f] consumes
   the element, and the loop consumes the entire array. *)

(* -------------------------------------------------------------------------- *)

(* Creating an empty array. *)

val zero : [a] () -> array a

(* Resetting an entire array. *)

val reset : [a, p : perm] (
  x: array a,
  f: (int | p) -> a
  | p) -> ()

(* Copying an entire array. *)

val copy : [a] array a -> array a

val map : [a, b, p : perm] (
  x: array a,
  f: (a | p) -> b
  | p
) -> array b

val mapi : [a, b, p : perm] (
  x: array a,
  f: (int, a | p) -> b
  | p
) -> array b

(* Filling a segment with a value. *)

val fill_segment : [a] duplicable a => (x: array a, i: int,   j: int, v: a) -> ()
val fill         : [a] duplicable a => (x: array a, i: int, len: int, v: a) -> ()
val fill_array   : [a] duplicable a => (x: array a, v: a) -> ()

(* -------------------------------------------------------------------------- *)

(* Conversions between arrays and lists. *)

val array2list : [a] duplicable a => array a -> list::list a
val list2array : [a] duplicable a => list::list a -> array a

(* -------------------------------------------------------------------------- *)

(* Sorting. *)

val sort : [a, p : perm] duplicable a => (
  cmp: (a, a | p) -> int,
  x: array a
  | p) -> ()
