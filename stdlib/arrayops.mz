open array

(* Operations on arrays. *)

(* -------------------------------------------------------------------------- *)

(* Generic loops over a segment of an array. *)

(* We use semi-open intervals of the form [i, j). That is, the index [i] is
   part of the interval, and the index [j] is not part of it. The interval
   is non-empty if and only if [i < j] holds. *)

val rec fold_segment_up [a] (
  i: int, j: int, consumes accu: a,
  f: (int, consumes a) -> a
) : a =
  if i < j then
    fold_segment_up (i + 1, j, f (i, accu), f)
  else
    accu

val rec fold_segment_down [a] (
  i: int, j: int, consumes accu: a,
  f: (int, consumes a) -> a
) : a =
  if i < j then
    fold_segment_down (i, j - 1, f (j - 1, accu), f)
  else
    accu

val rec iter_segment_up [p : perm] (
  i: int, j: int,
  f: (int | p) -> () 
  | p
) : () =
  if i < j then begin
    f(i);
    iter_segment_up (i + 1, j, f)
  end

val rec iter_segment_down [p : perm] (
  i: int, j: int,
  f: (int | p) -> () 
  | p
) : () =
  if i < j then begin
    f(j - 1);
    iter_segment_down (i, j - 1, f)
  end

(* Generic loops over an entire array. *)

val fold_array_up [a, b] (
  x: array a, consumes seed: b,
  f: (int, consumes b | x @ array a) -> b
) : b =
  fold_segment_up [a = (b | x @ array a)] (0, length x, seed, f)
  (* WISH could we get rid of this type application? *)

val fold_array_down [a, b] (
  x: array a, consumes seed: b,
  f: (int, consumes b | x @ array a) -> b
) : b =
  fold_segment_down [a = (b | x @ array a)] (0, length x, seed, f)
  (* WISH could we get rid of this type application? *)

val iter_array_up [a, p : perm] (
  x: array a,
  f: (int | x @ array a * p) -> ()
  | p
) : () =
  iter_segment_up (0, length x, f)

val iter_array_down [a, p : perm] (
  x: array a,
  f: (int | x @ array a * p) -> ()
  | p
) : () =
  iter_segment_down [ (x @ array a * p) ] (0, length x, f)

(* A variant of the above loops, where [f] receives not only an index [i],
   but also the corresponding array element. *)

val foldi_up [a, b] (
  x: array a, consumes seed: b,
  f: (int, a, consumes accu: b) -> b
) : b =
  fold_array_up (x, seed, fun (i: int, consumes accu: b | x @ array a) : b =
    consult (x, i, fun (v: a | consumes accu @ b) : b =
      f (i, v, accu)
    )
  )

val foldi_down [a, b] (
  x: array a, consumes seed: b,
  f: (int, a, consumes accu: b) -> b
) : b =
  fold_array_down (x, seed, fun (i: int, consumes accu: b | x @ array a) : b =
    consult (x, i, fun (v: a | consumes accu @ b) : b =
      f (i, v, accu)
    )
  )

val iteri_up [a, p : perm] (
  x: array a,
  f: (int, a | p) -> ()
  | p
) : () =
  iter_array_up (x, fun (i: int | x @ array a * p) : () =
    consult [pre = p, b = (| p)] (x, i, fun (v: a | p) : () =
      (* WISH could we get rid of this type application? *)
      f (i, v)
    )
  )

val iteri_down [a, p : perm] (
  x: array a,
  f: (int, a | p) -> ()
  | p
) : () =
  iter_array_down (x, fun (i: int | x @ array a * p) : () =
    consult [pre = p, b = (| p)] (x, i, fun (v: a | p) : () =
      (* WISH could we get rid of this type application? *)
      f (i, v)
    )
  )

(* A degenerate variant of the above loops, where the function [f] has
   access to the element, but not the index [i] or to the array [x]. *)

val fold_up [a, b] (
  x: array a,
  consumes seed: b,
  f: (a, consumes accu: b) -> b
) : b =
  fold_array_up (x, seed, fun (i: int, consumes accu: b | x @ array a) : b =
    consult (x, i, fun (v: a | consumes accu @ b) : b =
      f (v, accu)
    )
  )

val fold_down [a, b] (
  x: array a,
  consumes seed: b,
  f: (a, consumes accu: b) -> b
) : b =
  fold_array_down (x, seed, fun (i: int, consumes accu: b | x @ array a) : b =
    consult (x, i, fun (v: a | consumes accu @ b) : b =
      f (v, accu)
    )
  )

val iter_up [a, p : perm] (
  x: array a,
  f: (a | p) -> ()
  | p
) : () =
  iter_array_up (x, fun (i: int | x @ array a * p) : () =
    consult [pre = p, b = (| p)] (x, i, fun (v: a | p) : () =
      (* WISH could we get rid of this type application? *)
      f v
    )
  )

val iter_down [a, p : perm] (
  x: array a,
  f: (a | p) -> ()
  | p
) : () =
  iter_array_down (x, fun (i: int | x @ array a * p) : () =
    consult [pre = p, b = (| p)] (x, i, fun (v: a | p) : () =
      (* WISH could we get rid of this type application? *)
      f v
    )
  )


(*
Local Variables:
compile-command: "../mezzo arrayops.mz"
End:
*)
