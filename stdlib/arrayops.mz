open array

(* Operations on arrays. *)

(* -------------------------------------------------------------------------- *)

(* Generic loops over a segment of an array. *)

(* We use semi-open intervals of the form [i, j). That is, the index [i] is
   part of the interval, and the index [j] is not part of it. The interval
   is non-empty if and only if [i < j] holds. *)

val rec iter_segment_up [p : perm] (
  i: int, j: int,
  f: (int | p) -> () 
  | p
) : () =
  if i < j then begin
    f(i);
    iter_segment_up (i + 1, j, f)
  end

val rec iter_segment_down [p : perm] (
  i: int, j: int,
  f: (int | p) -> () 
  | p
) : () =
  if i < j then begin
    f(j - 1);
    iter_segment_down (i, j - 1, f)
  end

(* Generic loops over an entire array. *)

val rec iter_array_up [a, p : perm] (
  x: array a,
  f: (int | x @ array a * p) -> ()
  | p
) : () =
  iter_segment_up (0, length x, f)

val rec iter_array_down [a, p : perm] (
  x: array a,
  f: (int | x @ array a * p) -> ()
  | p
) : () =
  iter_segment_down [ (x @ array a * p) ] (0, length x, f)

(* A variant of the above loops, where [f] receives not only an index [i],
   but also the corresponding array element. *)

val rec iteri_up [a, p : perm] (
  x: array a,
  f: (int, a | x @ array a * p) -> ()
  | p
) : () =
  iter_array_up (x, fun (i: int | x @ array a * p) : () =
    f (i, get (x, i))
  )

val rec iteri_down [a, p : perm] (
  x: array a,
  f: (int, a | x @ array a * p) -> ()
  | p
) : () =
  iter_array_down (x, fun (i: int | x @ array a * p) : () =
    f (i, get (x, i))
  )

(* A degenerate variant of the above loops, where the function [f] has
   access to the element, but not the index [i] or to the array [x]. *)

val iter_up [a, p : perm] (
  x: array a,
  f: (a | p) -> ()
  | p
) : () =
  iter_array_up (x, fun (i : int | x @ array a * p) : () =
    f(get(x, i))
  )

val iter_down [a, p : perm] (
  x: array a,
  f: (a | p) -> ()
  | p
) : () =
  iter_array_down (x, fun (i : int | x @ array a * p) : () =
    f(get(x, i))
  )

(* A variant of the above loops, where the function [f] has access to
   an explicit loop-carried accumulator, in addition to the element. *)

val fold_up [a, b] (
  x: array a,
  consumes seed: b,
  f: (a, consumes accu: b) -> b
) : b =
  let accu = newref seed in
  iter_array_up (x, fun (i: int | x @ array a * accu @ ref b) : () =
    accu := f (get (x, i), !accu )
  );
  !accu

val fold_down [a, b] (
  x: array a,
  consumes seed: b,
  f: (a, consumes accu: b) -> b
) : b =
  let accu = newref seed in
  iter_array_down (x, fun (i: int | x @ array a * accu @ ref b) : () =
    accu := f (get (x, i), !accu )
  );
  !accu

(* -------------------------------------------------------------------------- *)

(* Creating an empty array. *)

val zero [a] () : array a =
  init (0, fun (i: int) : a = fail (* impossible *))

(* Resetting an entire array. *)
(* TEMPORARY could define [reset_segment] and view [reset] as a special case? *)

val reset [a, p : perm] (
  x: array a,
  f: (int | p) -> a
  | p) : () =
  iter_array_up (x, fun (i: int | x @ array a * p) : () =
    set (x, i, f i)
  )

(* Copying an entire array. *)
(* TEMPORARY will require duplicable a *)
val copy [a] (x: array a) : array a =
  sub (x, 0, length x)

val map [a, b, p : perm] (
  x: array a,
  f: (a | p) -> b
  | p
) : array b =
  (* It seems to work when [p] is not there and [x @ array a] must be guessed, but not
     in the more complex situation where [x @ array a * p] must be guessed. *)
  init (length x, fun (i: int | x @ array a * p) : b =
    f (get (x, i))
  )

val mapi [a, b, p : perm] (
  x: array a,
  f: (int, a | p) -> b
  | p
) : array b =
  init (length x, fun (i: int | x @ array a * p) : b =
    f (i, get (x, i))
  )

(* Filling a segment with a value. *)

val rec fill_segment [a] duplicable a => (x: array a, i: int, j: int, v: a) : () =
  if i < j then begin
    set (x, i, v);
    fill_segment (x, i + 1, j, v)
  end

val fill [a] duplicable a => (x: array a, i: int, len: int, v: a) : () =
  fill_segment (x, i, i + len, v)

val fill_array [a] duplicable a => (x: array a, v: a) : () =
  fill_segment (x, 0, length x, v)

(* -------------------------------------------------------------------------- *)

(* Conversions between arrays and lists. *)

(* Converting an array (segment) to a list. *)

(* BUG (known, I suppose): the names Cons and Nil should not be understood
   since I have not opened the list module. *)

val rec segment2list [a] duplicable a => (x: array a, i: int, j: int, consumes accu: list::list a) : list::list a =
  if i < j then
    segment2list (x, i, j - 1, Cons { head = get (x, j - 1); tail = accu })
  else
    accu

val array2list [a] duplicable a => (x: array a) : list::list a =
  segment2list (x, 0, length x, Nil)

(* Converting a list to an array. *)

(* This less elegant and less compact version is defined directly. Due to its
   use of [create], it is restricted to a duplicable element type. I keep only
   as a test of the type-checker. *)

val list2array [a] duplicable a => (xs: list::list a) : array a =
  match xs with
  | Nil ->
      zero ()
  | Cons { head; tail } ->
      let x = create (1 + list::length tail, head) in
      let rec fill (i: int, xs: list::list a | x @ array a) : =x =
	match xs with
	| Nil ->
	    x
	| Cons ->
	    set (x, i, xs.head);
	    fill (i + 1, xs.tail)
        end
      in
      fill (1, tail)
  end

(* This elegant and compact version is defined in terms of [init]. *)

val list2array [a] (consumes xs: list::list a) : array a =
  let n = list::length xs in
  let r = newref xs in
  init (n, fun (i: int | r @ ref (list::list a)) : a =
    match !r with
    | Cons { head; tail } ->
        r := tail;
        head
    | Nil ->
        fail (* impossible *)
    end
  )
(* BUG -- well, not quite but almost: if I omit the "consumes" annotation
   above, I get an error whose location is the line "let r = newref xs"
   whereas the error is really at the very end of the function, where a
   permission [xs @ list a] is missing. *)

(* -------------------------------------------------------------------------- *)

(* Sorting. *)

(* This is a port of OCaml's ternary heap sort. *)

(* The three children of the node [i] are [i31], [i31+1], and [i31+2], where
   [i31] stands for [i*3+1]. *)

val sort [a, p : perm] duplicable a => (
  cmp: (a, a | p) -> int,
  x: array a
  | p) : () =

  (* In all of the auxiliary functions that follow, [l] is the length of the
     array [x]. *)

  (* The function [maxson] tells which of the children of the node [i] has
     the greatest value. This node may have zero, one, two, or three children.
     If there is at least one child, then the call returns the index of the
     maximum child to the [normal] continuation. If there is zero child, then
     the call returns the index [i] to the [bottom] continuation. This is a
     double-barreled CPS encoding of the original OCaml code, which uses an
     exception to signal that we have hit the bottom. *)

  (* The [consumes] annotation on the three occurrences of [x @ array a] below
     seems to be optional. I believe that it should in principle be present.
     By omitting this annotation, we would be committing to preserving this
     permission, so we would be fixing a more specific type for [maxson]. In
     essence, we would be specializing the answer type [b] to a type of the
     form [b | x @ array a]. *)

  let maxson [b] (
    l: int, i: int,
    bottom: (int | consumes (p * x @ array a)) -> b,
    normal: (int | consumes (p * x @ array a)) -> b
                 | consumes (p * x @ array a))  : b =
    let i31 = i+i+i+1 in
    if i31+2 < l then begin
      (* If there are three children, find which one has the maximum value. *)
      let max = newref i31 in
      if cmp (get (x, i31),  get (x, i31+1)) < 0 then max := i31+1;
      if cmp (get (x, !max), get (x, i31+2)) < 0 then max := i31+2;
      normal !max
    end
    else if i31+1 < l then begin
      (* If there are just two children, find which one has the maximum value. *)
      let max = if cmp (get (x, i31), get (x, i31+1)) < 0 then i31+1 else i31 in
      normal max
    end
    else if i31 < l then
      (* If there is just one child, return it. *)
      normal i31
    else
      (* If there are no children, we have hit the bottom. Return [i]
	 via the exceptional continuation. *)
      bottom i
  in

  (* The function [trickledown] trickles the element [e] down node [i].
     The normal continuation is specialized to an empty continuation. *)

  let rec trickledown (
    l: int, i: int, e: a,
    bottom: (int | p * x @ array a) -> ()
    | p * x @ array a
  ) : () =
    maxson (* [b = (| p * x @ array a)] *) (l, i, bottom, fun (j: int | p * x @ array a) : () =
      (* [j] is the maximum son of [i]. If the element [e] is ? than the
	 element found at [j], then send it down, otherwise write [e] into
	 node [i]. *)
      if cmp (get (x, j), e) > 0 then begin
	set (x, i, get (x, j));
	trickledown (l, j, e, bottom)
      end
      else
	set (x, i, e)
    )
  in

  (* The function [trickle] provides [trickledown] with a bottom continuation
     that writes [e] into the childless node.  *)

  let trickle (l: int, i: int, e: a | p * x @ array a) : () =
    trickledown (l, i, e, fun (i: int | p * x @ array a) : () =
      set (x, i, e)
    )
  in

  (* The function [bubbledown] is analogous to [trickledown], but inserts a
     a hole, rather than an element. It never terminates normally, i.e. it
     always reaches a point where [maxson] invokes its bottom continuation.
     For this reason, we can supply an identity continuation to [maxson]. *)

  let identity (i: int | p * x @ array a) : int =
    i
  in

  let rec bubbledown (
    l: int, i: int
    | p * x @ array a
  ) : int =
    maxson (* [b = (int | p * x @ array a)] *) (l, i, identity, fun (j: int | p * x @ array a) : int =
      set (x, i, get (x, j));
      bubbledown (l, j)
    )
  in

  (* Trickle up... *)

  let rec trickleup (i: int, e: a | p * x @ array a) : () =
    let father = (i - 1) / 3 in
    if cmp (get (x, father), e) < 0 then begin
      set (x, i, get (x, father));
      if father > 0 then trickleup (father, e) else set (x, 0, e)
    end
    else
      set (x, i, e)
  in

  (* The main algorithm. *)

  let l = length x in
  iter_segment_down (0, (l + 1) / 3, fun (i: int | p * x @ array a) : () =
    trickle (l, i, get (x, i))
  );
  iter_segment_down (2, l, fun (i: int | p * x @ array a) : () =
    let e = get (x, i) in
    set (x, i, get (x, 0));
    trickleup (bubbledown (i, 0), e)
  );
  if l > 1 then
    swap (x, 0, 1)

(*
Local Variables:
compile-command: "../mezzo arrayops.mz"
End:
*)
