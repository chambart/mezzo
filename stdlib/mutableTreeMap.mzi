(* -------------------------------------------------------------------------- *)

(* [treeMap k c a] is an abstract type for association maps with keys of type
   [k] and values of type [a]. Entries are internally ordered using the key
   ordering [cmp]. *)

abstract treeMap k (cmp: term) a

(* [treeMap k c a] is an exclusive type. That is, a map has a unique owner. *)

fact exclusive (treeMap k cmp a)

(* -------------------------------------------------------------------------- *)

(* Operations on maps. *)

val create : [k, a] (cmp: (k, k) -> int) -> treeMap k cmp a

val singleton : [k, a] (cmp: (k, k) -> int, consumes k, consumes a) -> treeMap k cmp a

val cardinal : [k, cmp: term, a] treeMap k cmp a -> int

val is_empty : [k, cmp: term, a] treeMap k cmp a -> bool

val add : [k, cmp: term, a] (consumes k, consumes a, treeMap k cmp a) -> ()

(* BUG the grammar does not allow constraints as part of VAL declarations!
   perhaps we should think about making TyConstraint a more "ordinary"
   construct in the grammar of types.
val find : [k, cmp: term, a] duplicable a => (k, treeMap k cmp a) -> option a
*)

val update : [k, cmp: term, a, b, p : perm] (
  (consumes a | p) -> (a, b),
  k, treeMap k cmp a | p
) -> option b

val mem : [k, cmp: term, a] (k, treeMap k cmp a) -> bool

(* TEMPORARY
val min_binding : [k, cmp: term, a] duplicable k, duplicable a => treeMap k cmp a -> option (k, cmp: term, a)
val max_binding : [k, cmp: term, a] duplicable k, duplicable a => treeMap k cmp a -> option (k, cmp: term, a)
*)

val extract_min_binding : [k, cmp: term, a] treeMap k cmp a -> option (k, a)
val extract_max_binding : [k, cmp: term, a] treeMap k cmp a -> option (k, a)

val remove : [k, cmp: term, a] (k, treeMap k cmp a) -> option (k, a)

val iter : [k, cmp: term, a, p : perm] (
  f: (k,              a | p) -> bool,
         m: treeMap k cmp a | p) -> bool

val for_all :
  =iter

(* TEMPORARY add sugar for this declaration? *)

val exists : [k, cmp: term, a, p : perm] (
  f: (k,              a | p) -> bool,
         m: treeMap k cmp a | p) -> bool

(* TEMPORARY
val map [k, cmp: term, a1, a2, b, p : perm] duplicable k => (
  f: (k, consumes d:           a1 | p) -> (b           | d @           a2),
         consumes m: treeMap k cmp a1 | p) -> (treeMap k cmp b | m @ treeMap k cmp a2)

val copy : [k, cmp: term, a, b] duplicable k => (a -> b, treeMap k cmp a) -> treeMap k cmp b
*)

val fold_ascending : [k, cmp: term, a1, a2, b, p : perm] (
  f: (k, consumes d:           a1, consumes accu: b | p) -> (b | d @           a2),
         consumes m: treeMap k cmp a1, consumes accu: b | p) -> (b | m @ treeMap k cmp a2)

val fold_descending : [k, cmp: term, a1, a2, b, p : perm] (
  f: (k, consumes d:           a1, consumes accu: b | p) -> (b | d @           a2),
         consumes m: treeMap k cmp a1, consumes accu: b | p) -> (b | m @ treeMap k cmp a2)

val fold :
  =fold_ascending

val merge : [k, cmp: term, a, b, c] (
  f: (k, consumes option a, consumes option b) -> option c,
  consumes treeMap k cmp a,
  consumes treeMap k cmp b
) -> treeMap k cmp c

val split : [k, cmp: term, a] (
  k,
  consumes treeMap k cmp a
) -> (treeMap k cmp a, option a, treeMap k cmp a)

val filter : [k, cmp: term, a, b] (
  p: (k, consumes a) -> option b,
  consumes treeMap k cmp a
) -> treeMap k cmp b

val partition : [k, cmp: term, a, b, c] (
  p: (k, consumes a) -> choice b c,
  consumes treeMap k cmp a
) -> (treeMap k cmp b, treeMap k cmp c)

val compare : [k, cmp: term, a] (
  (k, k) -> int,
  (a, a) -> int,
  treeMap k cmp a,
  treeMap k cmp a
) -> int

val equal : [k, cmp: term, a] (
  (k, k) -> int,
  (a, a) -> int,
  treeMap k cmp a,
  treeMap k cmp a
) -> bool

(* TEMPORARY bindings *)
