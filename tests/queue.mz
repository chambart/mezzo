(* FIFO structure, adapted from queue.ml *)

mutable data cell a =
  Cell { value: a; next: dynamic }

(* The fifo structure is implemented with a cyclic list,
   with a pointer on the last element. An integer gives the
   length of the structure. The integer is extensively used
   in the ML version to test whether the structure is empty.
   Here a tag will do the trick in most cases.
*)

mutable data fifo a =
  Empty    { length: int;  tail: ()      }
| NonEmpty { length: int;  tail: dynamic }
adopts cell a

(* TEMPORARY this code is rejected because "adopts" clauses in
   structural types are not yet supported by the parser.
(* This internal function finds the head of a nonempty queue. *)

val head [a, tail : term] (q: NonEmpty { length: int; tail = tail } adopts cell a | tail @ dynamic) : dynamic =
  taking tail from q begin
    tail.next
  end
*)

val create [a] (): fifo a =
  Empty { length = 0;  tail = () }

val length [a] (q: fifo a): int =
  match q with
  | Empty -> 0
  | NonEmpty -> q.length
  end

(* The function clear doesn't type without the match *)

val clear [a] (q: fifo a): () =
  match q with
  | Empty -> ()
  | NonEmpty ->
      tag of q <- Empty;
      q.length <- 0;
      q.tail   <- ()
  end

val insert [a] (consumes x: a, q: fifo a): () =
  let c = Cell {
    value = x; next = ()
  } in
  match q with
  | Empty ->
      c.next <- c;
      give c to q;
      tag of q <- NonEmpty;
      q.length <- 1;
      q.tail <- c
  | NonEmpty { tail } ->
      taking tail from q begin
        c.next <- tail.next;
        tail.next <- c;
      end;
      give c to q;
      q.tail <- c;
      q.length <- q.length +1
  end
  
(* Peek: the element has to be duplicable. *)

val peek [a] duplicable a => (q: fifo a): option a =
  match q with
  | Empty -> 
      none
  | NonEmpty { tail } ->
      let head =
	taking tail from q begin
	  tail.next
	end
      in
      taking head from q begin
	some head.value
      end
  end

val retrieve [a] (q: fifo a): option a =
  match q with
  | Empty ->
      None
  | NonEmpty { tail } ->
      take tail from q; (* TEMPORARY why is there an "exclusive resource allocation conflict" here? *)
      let head = tail.next in
      if head == tail then begin
	tag of q <- Empty;
	q.length <- 0;
	q.tail <- ()
      end
      else begin
	q.length <- q.length - 1;
	take head from q;
	tail.next <- head.next;
	give tail to q
      end;
      (* At this point, we own the [head] cell. Note that this annotation
	 is not required. *)
      assert head @ cell a;
      (* The head cell must not be given back to the queue. We need to assert
	 the ownership of [head.value], whose type is not duplicable. *)
      some head.value
 end

(* TODO: deduce map from retrieve/insert *)
val map [a, b, p:perm] (f: (a | p) -> b, q: fifo a | p): fifo b =
  match q with
  | Empty ->
(* Type variable [b] has to be explicitly given in the empty case *)
      create [b] ()

  | NonEmpty { length; tail } ->
      take tail from q;

      let tail' = Cell { 
	value = f tail.value ; next = ()
      } in

      let q' = NonEmpty {
	length = length;
	tail = tail'
      } in

(* Doesn't type if no permission for q is explicited *)
      let rec ccopy (c: dynamic | q' @ fifo b * q @ fifo a * p): dynamic =
	if c == tail
	then tail'
	else begin
	  take c from q;
          let c' = Cell {
	    value = f c.value;
	    next = ccopy (c.next)
	  } in
	  give c to q;
	  give c' to q';
	  c'
	end
      in
      tail'.next <- ccopy (tail.next);

      give tail to q;
      give tail' to q';
 
      q'
      
  end 

val copy [a] duplicable a => (q: fifo a): fifo a =
  map ((fun (x:a): a = x), q)

(* In contrast with [list::fold], the function [queue::fold] cannot perform
   a strong update on the queue elements. The queue [q] adopts elements of
   type [cell a], and this cannot be changed. Thus, [queue::fold] must require
   its argument [f] to preserve the type [a] of the list element. *)

val fold [a, b, p:perm] (
  q: fifo a,
  consumes acc: b,
  f: (a, consumes b | p) -> b
| p
): b =
  
  match q with
  | Empty ->
      acc

  | NonEmpty { tail } ->

      let rec fold (consumes acc: b, c: dynamic | q @ fifo a): b =
	take c from q;
        let Cell { next; value } = c in
        let acc = f (value, acc) in
	give c to q;
        if tail == c then
          acc
        else
          fold (acc, next)
      in

      (* Obtain the address of the first cell. *)
      let head = taking tail from q begin tail.next end in
      (* We're ready to launch the recursion. *)
      fold (acc, head)

  end

val iter [a, p:perm] (q: fifo a, f: (a | p) -> () | p) : () =
  fold (q, (), fun (x:a, () | p): () = f x) 

(*
Local Variables:
compile-command: "../mezzo queue.mz"
End:
*)
