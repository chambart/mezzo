(* FIFO structure, adapted from queue.ml *)

mutable data cell a =
  Cell { value: a; next: dynamic }

(* The fifo structure is implemented with a cyclic list,
   with a pointer on the last element. An integer gives the
   length of the structure. The integer is extensively used
   in the ML version to test whether the structure is empty.
   Here a tag will do the trick in most cases.
*)

mutable data fifo a =
  Empty    { length: int;  tail: ()      }
| NonEmpty { length: int;  tail: dynamic }
adopts cell a

val create [a] (): fifo a =
  Empty { length = 0;  tail = () }

(* The function clear doesn't type without the match *)

val clear [a] (q: fifo a): () =
  match q with
  | Empty -> ()
  | NonEmpty ->
    tag of q <- Empty;
    q.length <- 0;
    q.tail   <- ()
  end

val insert [a] (consumes x: a, q: fifo a): () =
  let c = Cell {
    value = x; next = ()
  } in
  match q with
  | Empty ->
      c.next <- c;
      give c to q;
      tag of q <- NonEmpty;
      q.length <- 1;
      q.tail <- c
  | NonEmpty { tail } ->
      take tail from q;
        c.next <- tail.next ;
        tail.next <- c;
      give tail to q;
      give c to q;
      q.tail <- c;
      q.length <- q.length +1
  end
  
val push [a] (consumes x: a, q: fifo a): () =
  insert (x, q)

(* Peek: the element has to be duplicable. *)

val peek [a] duplicable a => (q: fifo a): option a =
  match q with
  | Empty -> 
      none
  | NonEmpty { tail } ->
      take tail from q;
        let head = tail.next in
        (* Head and tail have to be compared for the same cell 
	   not to be taken twice. *)
	let x = 
	  if tail == head 
	  then tail.value
	  else begin 
	    take head from q;
	      (* Returning a value and giving the cell back 
		 requires storing the value.
		 WISH: a command that takes a cell and gives it
		 back at the end of the code block, so that this
		 let y = ... is not needed anymore.
	      *)
	      let y = head.value in
	    give head to q;
	    y
	  end
	in
      give tail to q;
      some x
  end

val retrieve [a] (q: fifo a): option a =
  match q with
  | Empty ->
      None
  | NonEmpty { tail } ->
      q.length <- q.length - 1;
      take tail from q;
      let head = tail.next in
      let x = 
        if head == tail then begin
	  tag of q <- Empty;
	  q.length <- 0;
	  q.tail <- ();
	  tail.value
          (* Tail cell should not be given back to the queue! *)
	end else begin
	  take head from q;
	  tail.next <- head.next;
	  give tail to q;
	  head.value
	  (* Head cell should not be given back to the queue! *)
	end
      in
      some x
  end

val copy [a] duplicable a => (q: fifo a): fifo a =
  match q with
  | Empty ->
(* Type variable [a] has to be explicitly given in the empty case *)
      create [a] ()

  | NonEmpty { length; tail } ->
      take tail from q;

      let tail' = Cell { 
	value = tail.value ; next = ()
      } in

(* Doesn't type if no permission for q is explicited *)
      let rec ccopy (c: dynamic | q @ fifo a): dynamic =
	if c == tail
	then tail'
	else begin
	  take c from q;
          let c' = Cell {
	    value = c.value;
	    next = ccopy (c.next)
	  } in
	  give c to q;
	  c'
	end
      in
      tail'.next <- ccopy (tail.next);

      give tail to q;
 
      let q' = NonEmpty {
	length = length;
	tail = tail'
      } in

      q'
      
  end 

val map [a, b, p:perm] (f: (a | p) -> b, q: fifo a | p): fifo b =
  match q with
  | Empty ->
(* Type variable [a] has to be explicitly given in the empty case *)
      create [b] ()

  | NonEmpty { length; tail } ->
      take tail from q;

      let tail' = Cell { 
	value = f tail.value ; next = ()
      } in

(* Doesn't type if no permission for q is explicited *)
      let rec ccopy (c: dynamic | q @ fifo a * p): dynamic =
	if c == tail
	then tail'
	else begin
	  take c from q;
          let c' = Cell {
	    value = f c.value;
	    next = ccopy (c.next)
	  } in
	  give c to q;
	  c'
	end
      in
      tail'.next <- ccopy (tail.next);

      give tail to q;
 
      let q' = NonEmpty {
	length = length;
	tail = tail'
      } in

      q'
      
  end 

val iter [a, p:perm] (f: (a | p) -> (), q: fifo a | p) : () =

  match q with

  | Empty ->
      ()

  | NonEmpty { tail } ->
    take tail from q;

    (* The tail cell has already been taken: it shouldn't be taken 
       twice and its permission has to be explicitely given in the
       auxiliary function.
    *)
    let rec citer (c: dynamic | tail @ cell a | q @ fifo a | p): () =
      if c == tail
      then f tail.value
      else begin
	take c from q;
	f c.value;
	citer c.next;
	give c to q
      end
    in

    citer tail.next;
    give tail to q
	
  end    

(* Again, there's a design question here. We can either:
   i. require that the type of the elements in the fifo be duplicable, or
   ii. demand that [f] leaves its second argument unchanged.
   The core issue is that [f] must leave the elements in [q] intact, otherwise
   we'll never be able to give back "q @ fifo b" to the caller. So either [f]
   gives back the permission on its second argument (option ii.), or [fold] must
   be able to save a copy for itself (option i.)
*)
val fold [a, b, p:perm] (
  f: (consumes a, b | p) -> a,
  consumes acc: a,
  q: fifo b | p
): a =
  
  match q with
  | Empty ->
      acc

  | NonEmpty { tail } ->
      take tail from q;

      (* This intermediary function takes the "next" element as [dynamic]. It
       * checks *before* taking it from [q] that it is distinct from [tail], so
       * as not to cause a runtime error. *)
      let rec fold (consumes acc: a, c: dynamic | q @ fifo b): a =
        if tail == c then
          acc
        else begin
          take c from q;
          let Cell { next; value } = c in
          let acc = f (acc, value) in
          let r = fold (acc, next) in
          give c to q;
          r
        end
      in

      (* Bootstrap the fold *)
      let Cell { next; value } = tail in
      let acc = f (acc, value) in

      (* Now that we've taken the first cell, we're ready to launch the
       * recursion. *)
      let r = fold (acc, next) in

      (* We're done. *)
      give tail to q;

      r
  end
