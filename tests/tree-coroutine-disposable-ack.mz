open channel
(* open tree_iterator *)

data mutable tree a =
  Leaf
| Node { left: tree a; elem: a; right: tree a }

(* This function iterates over the tree, and submits the elements onto the
   channel [pipe]. Each element is sent together with a dedicated and
   disposable [ack] channel, on which the function waits for an
   acknowledgement. It then proceeds with the iteration. *)

(* Since the dedicated [ack] channel is defined to carry a permission [x @ a]
   where [x] is the hole of the iterator, this approach allows [a] to be
   exclusive. *)

val send_and_wait_ack [a] (x: a, pipe: channel ({x: term} (a, channel ( | x@a)))): () =
  let c = channel::new [( | x@a)] () in
  assert (c @ channel ( | x@a));
  assert ({y: term} (c @ channel ( | y@a)));
  send [a] (pipe, (x, c));
  receive c

val rec iter [a] duplicable a => (t: tree a, pipe: channel a, ack: channel bool) : bool =
  match t with
  | Leaf ->
      true
  | Node ->
      iter (t.left, pipe, ack) &&
      begin send (pipe, t.elem); receive ack end &&
      iter (t.right, pipe, ack)
  end 

(* Here is a client that receives the elements and counts them. Note that it
   has local state. *)

val count [a] (pipe: channel a, ack: channel bool) : () =
  let c = newref 0 in
  preserving c @ ref int while true do begin
    let x = receive pipe in
    incr c;
    send (ack, true)
  end
  (* Stupid. This point in the code is unreachable. *)

(* Now, combine the producer and consumer. We cheat by running the producer
   on the current thread. If we spawned a new thread, we would have to
   transmit [t @ tree a] to it, and get it back afterwards, using [join]. *)

val test [a] duplicable a => (t: tree a) : bool =
  let pipe, ack = new(), new() in
  thread::spawn (fun () : () =
    count (pipe, ack)
  );
  iter [a] (t, pipe, ack)
    (* Interesting example of a type application that is required. *)

(* TODO find a way of encoding the protocol when [a] is not duplicable.
   - possibly create one new [ack] channel for each element (not very nice)
   - possibly use a non-shareable channel, with explicit permissions to send
     and receive; send every element [x] on the pipe together with a permission
     to emit [x @ a] on the channel [ack]. Keep a permission to receive [x @ a]
     on [ack]. This requires the ability to manufacture a dual send/receive
     permission pair. Can we implement these controlled channels in the
     language? *)

(*
Local Variables:
compile-command: "../mezzo tree-coroutine.mz"
End:
*)
