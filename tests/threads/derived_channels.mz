open locks
open queue

(* Deriving channels using locks and queues. *)

(* A channel is a pair of a queue [q] and a lock that protects the
   exlucive permission on [q]. *)

data channel a =
  Channel { channel: (q: unknown, lock (q @ fifo a)) }

(* Channel creation. *)

val newchannel [a] (): channel a =
  let q = queue::create () in
  let l : lock (q @ fifo a) = newlock () in
  Channel { channel = (q, l) }

(* Send. *)

val send [a] (c: channel a, consumes x: a): () =
  let q, l = c.channel in
  acquire l;
  insert (x, q);
  release l

(* Receive. *)
(* Naive version with busy waiting. *)

val rec receive [a] (c: channel a): a =
  let q, l = c.channel in
  acquire l;
  match retrieve q with
  | None ->
    release l; receive [a] c
  | Some { contents = x } ->
    release l; x
  end 



(*
data channel a =
  Channel { queue: (queue: unknown); lock: lock (queue @ fifo a) }
*)

(*
val newchannel [a] (): channel a =
  let q = queue::create [a] () in
  let l = locks::newlock [(q @ fifo a)] () in
  Channel { queue = q; lock = l }
*)

(*
val send [a] (c: channel a, consumes x: a): () =
  match c with
  | Channel { q; l } ->
    acquire l;
    insert [a] (x, q);
    release l
  end
*)

(*
(* Naive version with busy waiting. *)
val rec receive [a] (c: channel a): a =
  match c with
  | Channel { q; l } ->
      acquire l;
      match retrieve [a] c with
      | None ->
	  release l; receive [a] c
      | Some { contents = x } ->
	  release l; x
      end
  end
*)

