open locks

(* The type I wish: a pointer to the contents of the thunk, and a lock
   that protects the exclusive permission to this contents. *)

data wref a =
  WRef { contents: (r: unknown, lock (r @ ref a)) }

(* Allocation. *)

val newwref [a] (consumes x: a) : wref a =
  let r = newref x in
  let l : lock (r @ ref a) = newlock () in
  WRef { contents = (r, l) }

(* Atomic swap. *)

val swap [a] (r: wref a, consumes x: a) : a =
  let r, l = r.contents in
  acquire l;
  let oldx = r.contents in
  r.contents <- x;
  release l;
  oldx

(* Get. *)

val get [a] duplicable a => (r: wref a) : a =
  let r, l = r.contents in
  acquire l;
  let oldx = r.contents in
  release l;
  oldx

(* Set. *)

val set [a] (r: wref a, consumes newx: a) : () =
  let r, l = r.contents in
  acquire l;
  r.contents <- newx;
  release l

(* Update. *)

val update [a, b, p : perm] (r: wref a, f: (consumes a | p) -> (a, b) | p) : b =
  let r, l = r.contents in
  acquire l;
  let new_content, result = f r.contents in
  r.contents <- new_content;
  release l;
  result

