(* A one-shot function is an affine resource. *)

(* A one-shot function is coded as a regular function [f] and an attached
   exclusive permission [p] that is required and consumed by any call
   to [f]. The permission [p] is quantified existentially. *)

(* This is a successful use of type abbreviation! *)

alias osf a b = {p: perm} (((consumes (a|p)) -> b) | p)


(* Creation. *)

(* One can build one-shot instances of any function. *)
(* The one-shot function is just the function. *)

val osf_make [a, b, p: perm] (f: (consumes (a | p)) -> b | consumes p): osf a b = f


(* Application. *)

(* Application of a one-shot function consumes the function. *)

val osf_apply [a, b] (consumes x: a, consumes f: osf a b): b = f x


(* Composition. *)

(* Strange case in [osf_compose]: the call to [osf_make] typechecks when
   no type application is provided. However it fails if the third argument
   (the permission to be hidden in the one-shot function) is given. *)

(* It appears that the call to [osf_apply] is not needed. The function 
   can be used like any other function! *)

val osf_compose [a, b, c] (consumes f: osf a b, consumes g: osf b c): osf a c=
  let h = fun (consumes x: a | consumes (f @ osf a b * g @ osf b c)): c=
    (*osf_apply (osf_apply (x, f), g)*)
    g (f x)
  in
  osf_make (*[a] [c] [(f @ osf a b * g @ osf b c)]*) h


(* The function below does not typecheck: one-shot functions can be used
   only once. *)

(*
val wrong (consumes f: osf () ()): ((), ())=
  (f (), f ())
*)


(* In the following other wrong function, any application of [f] after
   the line that defines [g] is rejected. Explanation: the application of
   [osf_make] to [f] refines the knowledge on the type of [f] by adding
   the precondition [consumes (r@ref ())]. Since [r] is consumed at the
   same time, [f] cannot be used anymore. *)

(* This calls for a new definition for one-shot functions, where a
   one-shot copy can be defined without affecting the original one. *)

(*
val wrong (f: () -> ()): ((), ())=
  let r = newref () in
  let g = osf_make [()] [()] [(r@ref ())] f in
  (g(),g())
*)

(*
Local Variables:
compile-command: "../mezzo oneshotfunction.mz"
End:
*)
