(* A one-shot function is an affine resource. *)

(* A one-shot function is coded as a pair of a regular function [f] and 
   an exclusive permission [p] that is required and consumed by any call
   to [f]. The permission [p] is quantified existentially. *)

data osf a b =
  | Osf { osf: {p: perm} ((consumes (a | p)) -> b | p) }

(* TEMPORARY: better with a type abbreviation! *)

(* Creation. *)

(* One can build one-shot instances of any function. *)

val osf_make [a, b, p: perm] (f: (consumes (a | p)) -> b | consumes p): osf a b =
  Osf { osf = f }

(* Application of a one-shot function consumes the function. *)

val osf_apply [a, b] (consumes x: a, consumes f: osf a b): b =
  f.osf x

(* Strange case in [osf_compose]: the call to [osf_make] typechecks when
   no type application is provided. However it fails if the third argument
   (the permission to be hidden in the one-shot function) is given. *)

val osf_compose [a, b, c] (consumes f: osf a b, consumes g: osf b c): osf a c=
  let h = fun (consumes x: a | consumes (f @ osf a b * g @ osf b c)): c=
    osf_apply (osf_apply (x, f), g)
  in
  osf_make (*[a] [c] [(f @ osf a b * g @ osf b c)]*) h


(* Is it possible to have a special, degenerated case of one-shot functions
   that would encode just the magic wand? *)

data magicwand p1 p2 =
  | MagicWand { mw: {q: perm} ( | consumes (p1 * q) -> ( | p2) | q) } 

(*
Local Variables:
compile-command: "../mezzo oneshotfunction.mz"
End:
*)
