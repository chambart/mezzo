data bool = True | False

(* Exemple v1 *)
data t = T

(* Exemples v2, v3 *)
data u = U { left: t; right: t }

(* Exemple v4 *)
data w a = W { w: a } | X

abstract int
fact duplicable int

(* Exemples v5, v6, v7, v8 *)

data v a b = A { a: a } | B { b: b } | C | D

(* Un exemple tout bête : on obtient

   v1 @ T {}
*)
val v1 =
  if True then
    T
  else
    T

(* Un exemple plus sophistiqué où l'on cherche à conserver le partage dans
   l'environnement de retour. On obtient

   ∃(? :: TERM). v2 @ U { left = ?; right = ? } ∗ ? @ T
*)
val v2 =
  if True then begin
    let x = T in
    U { left = x; right = x }
  end else begin
    let z = T in
    let y = T in
    U { left = y; right = y }
  end

(* Un exemple encore plus compliqué, où il y a du partage d'un côté mais pas de
   l'autre. Il est quand même possible d'obtenir une bonne permission en sortie
   pour le résultat de ce if, car le type [t] est duplicable ce qui permet
   d'utiliser (à gauche) [x @ T] deux fois. On obtient

   ∃(?, ?' :: TERM). v3 @ U { left = ?; right = ?' } ∗ ? @ T ∗ ?' @ T

   À noter qu'on ne peut plus obtenir [v3 @ u] si jamais l'on déclare [t] comme
   étant exclusif.
*)
val v3 =
  if True then begin
    let x = T in
    U { left = x; right = x }
  end else begin
    let z = T in
    let y = T in
    U { left = y; right = z }
  end

(* Un premier exemple, avec une variable flexible déjà... On obtient :

   v4 @ w int
*)
val v4 =
  if True then
    W { w = 1 }
  else
    X

(* Quelques exemples avec le type [v]. Celui-ci est très simple, et permet de
   tester la situation où l'on doit réconcilier deux constructeurs différents
   pour le même type. On obtient :
   
   v5 @ v int int
*)
val v5 =
  if True then
    A { a = 1 }
  else
    B { b = 2 }

(* Là on aimerait avoir une valeur généralisée pour [v5], idéalement :

   v6 @ ∀b. v int b 
*)
val v6 =
  if True then
    A { a = 1 }
  else
    C

(* Idem.

   v7 @ ∀ab. v a b 
*)
val v7 =
  if True then
    D
  else
    C

(* Cet exemple oblige à avoir une opération de soustraction avec des flexibles à
   gauche et à droite. Comme on travaille avec des types duplicables, deux
   permissions seront disponibles pour [v6]. On aura de même une soustraction
   avec des flexibles si l'on fait :

   data list' a = Nil | Nil' | Cons { ... }
   val x = length (if True then Nil else Nil')

   parce que la soustraction fera list a* - list b* avec a* et b* flexibles.
   Dans ce cas-là, la bonne réponse est d'unifier, et d'accepter l'argument.
   Dans l'exemple avec [v6], on exerce en plus le cas dans [merge_types] où l'on
   a des flexibles des deux côtés, et qu'on doit merger ça en une même flexible
   dans l'environnement de destination. Tout ça pour obtenir :

   v8 @ ∀ab. v a b ∗ v6 @ ∀a. v a a
*)
val (v8: [a] v a a) =
  if True then
    D
  else
    C
