(* The [pack] is a one-shot unit function, encoded by an 
   existential permission. *)
data pack =
  | Pack { func: {p: perm} ((consumes (|p)) -> () | p) }

(* Building a [pack] requires consuming a permission. *)
val make_pack [p: perm] (f: (consumes (|p)) -> () | consumes p): pack =
  Pack { func = f }

(* The function [repack] builds a function that opens its argument
   and puts it in a new pack. *)
val repack (consumes f: pack): pack=
  let h = fun (consumes (x: () | f@pack)): ()=
    f.func x
  in
(* The type application below is supposed to be the one that is expected.
   However, the code does not typecheck anymore if the type application
   gets uncommented. *)
  make_pack [(f@pack)] h



(*
(* Composition was the original case, but it is not needed. *)
val compose_pack (consumes f: pack, consumes g: pack): pack=
  let h = fun (consumes x: () | consumes (f @ pack * g @ pack)): ()=
    g.func (f.func x)
  in
  make_pack (*[(f @ pack * g @ pack)]*) h
*)



(*
(* The problem does not appear without a function. *)
data spack =
  | SPack { d: {p: perm} (|p) }

val make_spack [p: perm] (d: () | consumes p): spack =
  SPack {d=d}

val srepack (consumes d: spack): spack=
  make_spack [(d@spack)] d.d
*)
