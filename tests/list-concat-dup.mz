data list a = Cons { head: a; tail: list a } | Nil

val rec concat [a] duplicable a => (xs: list a, ys: list a): list a =
  match xs with
  | Nil ->
      ys
  | Cons ->
      Cons {
        head = xs.head;
        (* The polymorphic instantiation is mandatory. If we omit it, we use a
         * flexible variable α to represent the polymorphic variable a in the
         * recursive call. Because α is not yet determined, we don't have any
         * hypotheses on it, and we can't satisfy the (duplicable α) constraint
         * that appears in the recursive call, so we fail. We could be more
         * clever, and perform the subtraction anyway and, if the subtraction
         * instantiates α, check afterwards that the instantiation we picked
         * does satisfy (duplicable α).
         *
         * 20121011: the trick above doesn't work, because when type-checking a
         * function call, we first subtract "duplicable a => (=x, =y)" and then
         * we subtract "x @ a ∗ y @ list a", so that doesn't help. *)
        tail = concat (xs.tail, ys)
      }
  end

