open atomic (* newlock, acquire, release *)
open hashtable (* table, create, find, add *)

(* [memoize (hash, eq, f)] builds a memoizing version of the function [f],
   using an internal hash table based on the provided hash and equality
   functions. *)

(* A lock is used to protect the hash table and to allow its use in a
   duplicable object (the memoized function). Here, a sequential lock
   (provided by the module [atomic]) is used, but in a multi-threaded
   setting, a "real" concurrent lock should be used. *)

val memoize
  [a, b]
  duplicable a => duplicable b =>
  (hash: a -> int, eq: (a, a) -> bool, f: a -> b) : (a -> b) =

  (* Create the internal hash table. *)
  let t = create [a, b] (11, hash, eq) in
  (* Create a lock which (at runtime) prevents re-entrant calls
     into the memoized function and (at type-checking time) allows
     us to hide the existence of the hash table. *)
  let l = newlock [(t @ table a b)] () in

  (* Now, construct the memoized function. *)
  fun (x: a) : b =
    (* Acquire the lock. This yields the permission [t @ table a b]. *)
    acquire l;
    (* Find [y] in the table, if it is there already, or compute [y]
       and store it in the table for potential later re-use. *)
    let y : (b | t @ table a b) =
      match find (x, t) with
      | Some { contents = y } ->
	  y
      | None ->
          let y = f x in
	  add (x, y, t);
	  y
      end
    in
    (* Release the lock. This consumes [t @ table a b]. *)
    release l;
    (* Return [y]. *)
    y

