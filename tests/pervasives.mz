(* Standard types *)

data option a = Some { contents: a } | None

data choice a b =
  | Left  { contents: a }
  | Right { contents: b }

mutable data ref a = Ref {
  contents: a;
}

(* Standard types *)

val none =
  None

val some [a] (consumes x: a): option a =
  Some { contents = x }

val true = True
val false = False

(* References *)

val newref [a] (consumes x: a): ref a =
  Ref { contents = x }

val (!) [y : TERM] (x: ref (=y)): =y =
  x.contents

val (:=) [a, b] (consumes x: ref a, consumes c: b): ( | x @ ref b) =
  x.contents <- c

(* Booleans *)

val not (b : bool) : bool =
  if b then False else True

