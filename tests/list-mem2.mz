open List

(* This is a variant of [List::mem]. It is defined in terms of [find] instead of
   being defined directly. *)

val mem2 [a] duplicable a => (equal: (a, a) -> bool, x: a, consumes xs: list a) : list a =
  let p (y: a) : bool =
    equal (x, y)
  in
  (* The type simplification phase yields, in the internal syntax,
   * "p @ [a, y :: term] (=y | y @ a) -> bool" instead of :
   * "p @ [a, y :: term] (=y | y @ a) -> (bool | y @ a)"; this is legal: "a" is
   * duplicable.
   *
   * However, when comparing this type with the expected type in "find", unless
   * we explicitly instanciate the type variable as below, we will introduce a
   * flexible variable and compare:
   * "p @ [a, y :: term] (=y | y @ a) -> bool" with:
   * "p @ [α, υ :: term] (=υ | υ @ α) -> (bool | υ @ α)" where greek letters
   * stand for flexible variables. Because we have no duplicity hypothesis on
   * these flexible variables, the comparison fails. The solution here is to
   * instanciate the type variable -- this is a bad interaction between our
   * local inference and duplicity constraints. *)
  find [a] (p, xs)

