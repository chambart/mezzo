open lock
open nest

(* This version of persistent arrays uses nesting instead of adoption/abandon.
   Compare with the version in the standard library. *)

(* ---------------------------------------------------------------------------- *)

(* The internal representation of persistent arrays is essentially unchanged.
   The main difference is that the type [dynamic] is replaced with the type
   [p: unknown | nests r (p @ point r a)], which represents a point that
   inhabits the region [r]. This type is duplicable. *)

(* Unfortunately, it seems that I cannot use [wref] any more, because I need
   to name the region [r], in order to refer to it in the permission
   [nests r ...]. *)

(* TEMPORARY a type abbreviation, or a data type where the field
   names are binders, would be useful. *)

data parray a =
  PArray { contents: (
    (* The region which this persistent array is part of. *)
    r: unknown,
    (* A lock, which gives access to this region. *)
    l: lock (r @ region),
    (* The point in the region which represents this persistent array. *)
    p: unknown | nests r (p @ point r a)
  ) }

(* A region nests a set of points. *)

mutable data region =
  Region

(* The representation of points is unchanged. *)

mutable data point (r : term) a =
| PFlat { contents: array a;                                unused1: (); unused2: () }
| PUndo { previous: (p: unknown | nests r (p @ point r a)); offset: int; element:  a }

(* ---------------------------------------------------------------------------- *)

(* Creation of a new persistent array. *)

val create [a] duplicable a => (n: int, x: a) : parray a =
  (* Create the point [p]. *)
  let t = array::create (n, x) in
  let p = PFlat { contents = t; unused1 = (); unused2 = () } in
  (* Create the region [r] and make [p] an element of it. *)
  let r = Region in
  nest [(p @ point r a), region] r;
  (* BUG 1: if I replace the above line by
  nest [(p @ point r a), Region] r;
  then I get:
  Mezzo internal error: FIXME *)
  (* BUG 2: if I replace the above line by
  nest [(p @ point r a)] r;
  then I get:
  one of the following constraints cannot be satisfied: exclusive (flexâ†’Region) *)
  (* Create a lock that protects [r]. *)
  let l : lock (r @ region) = lock::new () in
  (* Done. *)
  PArray { contents = (r, l, p) }

(* ---------------------------------------------------------------------------- *)

val rec revert [a] duplicable a =>
  (consumes r: region, p: unknown | nests r (p @ point r a))
: (array a | p @ PUndo { previous: unknown; offset: unknown; element: unknown }
           * r @ punched region (p @ point r a))
=
  (* Take [p] out of the region [r]. *)
  focus [a = region] r;
  (* TEMPORARY the annotation should be unnecessary; same thing for other occurrences of focus *)
  match p with
  | PFlat ->
      let t = p.contents in
      tag of p <- PUndo;
      t
  | PUndo ->
      revert_link (r, p)
  end

and revert_link [a] duplicable a =>
  (r: punched region (p @ point r a),
   consumes p: PUndo { previous: (previous: unknown | nests r (previous @ point r a)); offset: int; element: a }
 | nests r (p @ point r a))
: (array a | p @ PUndo { previous: unknown; offset: unknown; element: unknown })
=
  let previous = p.previous in
  (* We must give [p] back to the region before the recursive call.
     We read [p.offset] and [p.element] now, while we have access
     to [p], because it will be difficult/impossible later, once
     we have focused on [previous]. *)
  let i = p.offset in
  let v = p.element in
  defocus r;
  (* Now that we could in principle loop if there is a cycle in
     the graph, while the version based on [dynamic] cannot loop;
     it will fail at runtime instead. *)
  let t = revert (r, previous) in
  (* Now, we are focused on [previous]. *)
  previous.previous <- p;
  previous.offset <- i;
  previous.element <- array::get (t, i);
  assert previous @ point r a; (* sanity check *)
  defocus r;
  array::set (t, i, v);
  (* The point [p] is in the desired state: its tag is [PUndo]. Unfortunately,
     we have forgotten this information by giving [p] back to [r] above, so we
     have to explicitly recover it. *)
  focus [(p @ point r a), region] r;
  match p with PFlat -> fail | PUndo -> () end;
  t

val reroot [a] duplicable a => (
  consumes r: region,
  p: unknown | nests r (p @ point r a)
)
: (t: array a | p @ PFlat { contents = t; unused1: (); unused2: () }
              * r @ punched region (p @ point r a))
=

  focus [a = region] r;
  match p with
  | PFlat ->
      p.contents
  | PUndo ->
      let t = revert_link (r, p) in
      tag of p <- PFlat;
      p.contents <- t;
      p.unused1 <- ();
      p.unused2 <- ();
      t
  end

(*
(* ---------------------------------------------------------------------------- *)

(* Temporary access to the underlying array. *)

(* TEMPORARY [borrow] is dangerous, because [f] is given read/write
   access to the underlying array, which it must promise not to modify.
   Thus, we do not publish it. If we had a [const] modifier, we would
   be able to publish it. *)

val borrow [a, b, p : perm] duplicable a => (
  pa: parray a, 
  f: (array a | consumes p) -> b
| consumes p
) : b =
  (* Acquire the lock, so as to get access to the region [r]. *)
  wref::borrow (pa.region, fun (r : region a | consumes p) : b =
    (* Re-root the persistent array at [p]. *)
    let p = pa.point in
    let t = reroot (r, p) in
    (* [p] is now flat. Pass the underlying array to [f]. *)
    let result = f t in
    (* Give [p] back to [r]. *)
    give p to r;
    (* Done. *)
    result
  )

(* ---------------------------------------------------------------------------- *)

(* Read access. *)

val get [a] duplicable a => (pa: parray a, i: int) : a =
  borrow (pa, fun (t: array a) : a =
    array::get (t, i)
  )

(* ---------------------------------------------------------------------------- *)

(* Write access. *)

(* [set] cannot be defined in terms of [borrow], because it needs access not
   only to the underlying array [t], but also to the point [p]. We could
   define a slightly more general version of [borrow] that provides us with
   [t] and [p]. We will see. *)

val set [a] duplicable a => (pa: parray a, i: int, v: a) : parray a =
  (* Acquire the lock, so as to get access to the region [r]. *)
  wref::borrow (pa.region, fun (r : region a) : parray a =
    (* Re-root the persistent array at [p]. *)
    let p = pa.point in
    let t = reroot (r, p) in
    (* [p] is now flat. Access the underlying array [t], and update [p]. *)
    tag of p <- PUndo;
    p.offset <- i;
    p.element <- array::get (t, i);
    (* Update the underlying array. *)
    array::set (t, i, v);
    (* Create a new point [q]. *)
    let q = PFlat { contents = t; unused1 = (); unused2 = () } in
    give q to r;
    (* Finish updating [p], and give it back. *)
    p.previous <- q;
    give p to r;
    (* Wrap the resulting point as a new persistent array. *)
    PArray { region = pa.region; point = q }
  )

*)
(*
Local Variables:
compile-command: "../mezzo persistentarray_nesting.mz"
End:
*)
