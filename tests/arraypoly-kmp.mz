open arraypoly

(* Implementation of the KMP algorithm *)
(* This implemtation works only for type [array m a] with a duplicable, because
 * we need to compare two elements of the same array, which is impossible with
 * the actual array interface. *)

(*
val array_eq [a, m1, m2] (
  r1: array m1 a,
  i: int,
  r2: array m2 a,
  j: int,
  eq: (a, a) -> bool
) : bool =
  consult [b = (bool | r2 @ array m2 a)] (r1, i, fun (x: a | r2 @ array m2 a) : bool =
    consult [b = (bool | x @ a)] (r2, j, fun (y: a | x @ a) : bool =
      eq (x, y)
    )
  )
*)

val build_table [a, m] duplicable a => (
  needle: array m a,
  eq: (a, a) -> bool
) : iarray int =
  let table = create (length needle, 0) in
  set (table, 0, -1);

  let rec loop (i: int, j: int | needle @ array m a * table @ marray int) : () =
    if i >= length needle
    then ()
    else if eq (get (needle, i-1), get(needle, j))
    then begin
      set(table, i, j+1);
      loop (i+1, j+1)
    end
    else if j > 0
    then loop(i, get(table, j))
    else begin
      set(table, i, 0);
      loop(i+1, 0)
    end
  in
  loop (2, 0);
  freeze table;
  table

val search [a, m1, m2] duplicable a => (
  needle: array m1 a,
  haystack: array m2 a,
  eq: (a, a) -> bool
) : int =
  let table = build_table (needle, eq) in
  let rec loop (
    m: int, i: int 
    | needle @ array m1 a * haystack @ array m2 a)
  : int =
    if m + 1 >= length haystack
    then length haystack
    else if eq (get (needle, i), get(haystack, m + i))
    then begin
      if i == length needle - 1
      then m
      else loop(m, i+1)
    end
    else
      loop(m + i - (get (table, i)), 
        if get (table, i) > -1
        then get (table, i)
        else 0)
  in loop (0, 0)
