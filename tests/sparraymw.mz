(* Another attempt at semi-persistent arrays, that does not rely on
   one-shot functions. Instead, an explicit type is given for "incomplete"
   arrays, which is an instance of the magic wand. *)

mutable data sparray a =
  | SPArray { repr: repr a (sparray a) }

mutable data repr a b =
  | RFlat { contents: array a }
  | RUndo { descendant: b; offset: int; element: a }

mutable data sparraymw a (s: term) =
  | SPArrayMW { repr: repr a (=s) }

val create [a] duplicable a => (size: int, element: a): sparray a =
  SPArray {
    repr = RFlat {
      contents = array::create (size, element)
    }
  }

val rec reroot [a] (consumes spa: sparray a):
  ( | spa @ SPArray { repr: RFlat { contents: array a } }) =
  match spa.repr with
  | RFlat {} ->
    ()
  | RUndo { descendant; offset; element } ->
    reroot descendant;
    let n = descendant.repr in
    let a = n.contents in
    array::set (a, offset, element);
    spa.repr <- n
  end 

val set [a] duplicable a =>
  (consumes spa: sparray a, offset: int, element: a):
  (spa': sparray a | spa @ sparraymw a spa') =
  reroot spa;
  let r = spa.repr in
  let arr = r.contents in
  let old_x = array::get(arr, offset) in
  array::set(arr, offset, element);
  let spa' = SPArray { repr = r } in
  spa.repr <- RUndo { descendant = spa'; offset = offset; element = element };
  tag of spa <- SPArrayMW;
  spa'
