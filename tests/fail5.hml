exclusive data ref a = Ref { contents: a }
abstract int
fact duplicable int

(* That example is correct but the type-checker doesn't have a linearity
 * analysis for the [ref] type. A value of type [ref] may contain at most one
 * pointer to its argument so it's safe to apply the singleton subtyping rule
 * here. *)
val f (consumes x: ref (=y), consumes y: ref int): ref (ref int) =
  x
