open list
open choice

data iterator_s a (s: perm) (post: perm) = Iterator {
  next: (| consumes s) -> choice (a | s) (| post);
  stop: (| consumes s) -> (| post)
| s }

alias iterator a (post: perm) = { s: perm } iterator_s a s post 

val new [a, iter, post: perm] (
  consumes it: iter,
  next: (consumes it: iter) -> choice (a | it @ iter) (| post),
  stop: (consumes it: iter) -> (| post)
): iterator a post
=
  Iterator {
    next = (fun (| consumes (it @ iter)): choice (a | it @ iter) (| post) = next it);
    stop = (fun (| consumes (it @ iter)): (| post) = stop it)
  }

(* filter: constructs a new iterator, returning only the elements of
   [it] that match the predicate [f] *)
val filter [a, post: perm, p: perm] (
  consumes it: iterator a post,
  pred: (a | p) -> bool
| consumes p): iterator a (post * p)
=
  let rec next
      (| consumes (it @ iterator a post * p)):
      choice (a | it @ iterator a post * p) (| post * p) =
    match it.next () with
    | Right ->
      right ()
    | Left { contents = x } ->
      if pred x then
	left x
      else
	next ()
    end 
  in

  let stop (| consumes (it @ iterator a post * p)):
      (| post * p) =
    it.stop ()
  in

  Iterator { next; stop }

(* map: constructs a new iterator, returning [f x] for each element
   [x] of [it]. *)
val map [a, b, post: perm, p: perm] (
  consumes it: iterator a post,
  f: (consumes a | p) -> b
| consumes p): iterator b (post * p)
=
  let next
      (| consumes (it @ iterator a post * p)):
      choice (b | it @ iterator a post * p) (| post * p) =
    match it.next () with
    | Right ->
      right ()
    | Left { contents = x } ->
      left (f x)
    end 
  in

  let stop (| consumes (it @ iterator a post * p)): (| post * p) =
    it.stop ()
  in

  Iterator { next; stop }

open duplist_iterator

val _ =
  let l = three (1, 2, 3) in
  let i = new_iterator_dup l in
  
  let it = new (i, next_dup, stop_dup) in
  let mit = map (it, fun (x: int): () = print x) in
  
  let rec loop [a, post: perm] (consumes it: iterator a post): (| post) =
    match it.next () with
    | Right ->
      ()
    | Left { contents = x } ->
      loop it
    end 
  in
  loop mit;
  ()
