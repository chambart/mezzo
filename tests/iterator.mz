open list
open choice

data iterator_s a (s: perm) (post: perm) = Iterator {
  next: (| consumes s) -> choice (a | s) (| post);
  stop: (| consumes s) -> (| post)
| s }

alias iterator a (post: perm) = { s: perm } iterator_s a s post 

val new [a, iter, post: perm] (
  consumes it: iter,
  next: (consumes it: iter) -> choice (a | it @ iter) (| post),
  stop: (consumes it: iter) -> (| post)
): iterator a post
=
  Iterator {
    next = (fun (| consumes (it @ iter)): choice (a | it @ iter) (| post) = next it);
    stop = (fun (| consumes (it @ iter)): (| post) = stop it)
  }

(* Calls [f] on each element of the iterator [it] *)
val rec iter [a, post: perm, p: perm] (
  consumes it: iterator a post,
  f: (consumes a | p) -> ()
| p): (| post)
=
  match it.next () with
  | Right ->
    ()
  | Left { contents = x } ->
    f x;
    iter (it, f)
  end 

(* filter: constructs a new iterator, returning only the elements of
   [it] that match the predicate [f] *)
val filter [a, post: perm, p: perm] (
  consumes it: iterator a post,
  pred: (a | p) -> bool
| consumes p): iterator a (post * p)
=
  let rec next
      (| consumes (it @ iterator a post * p)):
      choice (a | it @ iterator a post * p) (| post * p) =
    match it.next () with
    | Right ->
      right ()
    | Left { contents = x } ->
      if pred x then
	left x
      else
	next ()
    end 
  in

  let stop (| consumes (it @ iterator a post * p)):
      (| post * p) =
    it.stop ()
  in

  Iterator { next; stop }

(* map: constructs a new iterator, returning [f x] for each element
   [x] of [it]. *)
val map [a, b, post: perm, p: perm] (
  consumes it: iterator a post,
  f: (consumes a | p) -> b
| consumes p): iterator b (post * p)
=
  let next
      (| consumes (it @ iterator a post * p)):
      choice (b | it @ iterator a post * p) (| post * p) =
    match it.next () with
    | Right ->
      right ()
    | Left { contents = x } ->
      left (f x)
    end 
  in

  let stop (| consumes (it @ iterator a post * p)): (| post * p) =
    it.stop ()
  in

  Iterator { next; stop }

(* Classical fold_left on the elements of the iterator *)
val rec fold_left [a, b, post: perm] (
  f: (consumes b, consumes x: a) -> b,
  consumes accu: b,
  consumes it: iterator a post
): (b | post)
=
  match it.next () with
  | Right ->
    accu
  | Left { contents = x } ->
    fold_left (f, f (accu, x), it)
  end 

(* Classical fold_right on the elements of the iterator *)
val rec fold_right [a, b, post: perm] (
  f: (consumes x: a, consumes b) -> b,
  consumes it: iterator a post,
  consumes accu: b
): (b | post)
=
  match it.next () with
  | Right ->
    accu
  | Left { contents = x } ->
    f (x, fold_right (f, it, accu))
  end 

(* [fold_left_it] returns an iterator returning the successive accumulators
   of a [fold_left]. Thus, this equality holds:

   fold_left (f, acc, it) = option::force (last (fold_left_it (f, acc, it)))
*)
(* TEMPORARY We require the accumulator type to be duplicable, but it
   may not be necessary if we use an idiom like [borrowed] of
   [fpiterator.mz]
*)
val fold_left_it [a, b, post: perm] duplicable b => (
  f: (consumes b, consumes x: a) -> b,
    consumes accu: b,
    consumes it: iterator a post
): iterator b post
  =
  let acc = newref accu in
  let alias st: perm = acc @ ref (duplicable b | b) * f @ (consumes b, consumes x: a) -> b in

  map [p = st] (
    it,
    (fun (consumes x: a | st): b =
	acc := f (!acc, x);
     !acc)
  )

(* Drops the [n] first elements of the iterator - that is, [drop]
   calls [it.next ()] [n] times *)
val rec drop [a, post: perm] (
  consumes it: iterator a post,
  n: int
): choice (| it @ iterator a post) (| post)
  =
  if n <= 0 then
    left ()
  else
    match it.next () with
    | Right ->
      right ()
    | Left ->
      drop (it, n-1)
    end 

(* Drops elements of [it] of the iterator while the predicate [pred]
   evaluates to [True] on them *)
val rec dropWhile [a, post: perm, p: perm] (
  consumes it: iterator a post,
  pred: (a | p) -> bool
| p): choice (a | it @ iterator a post) (| post)
=
  match it.next () with
  | Right ->
    right ()
  | Left { contents = x } ->
    if not (pred x) then
      left x
    else
      dropWhile (it, pred)
  end 

(* Returns the last element of the iterator, or [None] if [it] is
   empty *)
val last [a, post: perm] (
  consumes it: iterator a post
): (option a | post)
  =
  let previous = newref None in
  iter (
    it,
    (fun (consumes x: a | previous @ ref (option a)): () =
	(previous := some x))
  );
  !previous

open duplist_iterator

val _ =
  let l = three (1, 2, 3) in
  let i = new_iterator_dup l in
  
  let it = new (i, next_dup, stop_dup) in
  let mit = map (it, fun (x: int): () = print x) in
  
  iter (
    mit,
    (fun (consumes x: ()): () = ())
  )
