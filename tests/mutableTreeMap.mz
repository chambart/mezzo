open pervasives (* TEMPORARY *)

mutable data tree k a =
  | Empty
  | Node { left: tree k a; key: k; value: a; right: tree k a; height: int }

val max (x: int, y: int) : int =
  if x >= y then x else y

val height [k, a] (t: tree k a) : int =
  match t with
  | Empty -> 0
  | Node  -> t.height
  end

(* TEMPORARY [create] is possibly unused? *)
val create [k, a] (consumes (l: tree k a, x: k, d: a, r: tree k a)) : tree k a =
  Node {
    left = l;
    key = x;
    value = d;
    right = r;
    height = max (height l, height r) + 1
  }

val singleton [k, a] (consumes (x: k, d: a)) : tree k a =
  create (Empty, x, d, Empty)

val update_height [k, a] (t: Node { left: tree k a; key: k; value: a; right: tree k a; height: int }) : () =
  t.height <- max (height t.left, height t.right) + 1

val bal [k, a] (consumes t: Node { left: tree k a; key: k; value: a; right: tree k a; height: int }) : tree k a =

  (* Extract the two sub-trees and their heights. *)
  let Node { left = l; right = r } = t in
  let hl = height l
  and hr = height r in

  (* Determine whether the tree is unbalanced and needs to be repaired. *)

  (* Situation 1: the left sub-tree is too big. *)
  if hl > hr + 2 then match l with
  | Empty -> fail (* impossible! *)
  | Node { left = ll; right = lr } ->
      if height ll >= height lr then begin
	(* The left node becomes the root node. *)
	(* The root node becomes the right child. *)
	t.left <- lr;
	update_height t;
	l.right <- t;
	update_height l;
	l
      end
      else match lr with
      | Empty -> fail (* impossible! *)
      | Node { left = lrl; right = lrr } ->
	  (* The node [lr] becomes the root node. *)
	  (* The root node becomes the right child. *)
	  (* The left node remains the left child. *)
	  l.right <- lrl;
	  update_height l;
	  t.left <- lrr;
	  update_height t;
	  lr.left <- l;
	  lr.right <- t;
	  update_height lr;
	  lr
      end
  end

  (* Situation 2: the right sub-tree is too big. *)
  else if hr > hl + 2 then match r with
  | Empty -> fail (* impossible! *)
  | Node { left = rl; right = rr } ->
      if height rr >= height rl then begin
	(* The right node becomes the root node. *)
        (* The root node becomes the left child. *)
	t.right <- rl;
	update_height t;
	r.left <- t;
	update_height r;
	r
      end
      else match rl with
      | Empty -> fail (* impossible! *)
      | Node { left = rll; right = rlr } ->
	  (* The node [rl] becomes the root node. *)
	  (* The root node becomes the left child. *)
	  (* The right node remains the right child. *)
          t.right <- rll;
	  update_height t;
	  r.left <- rlr;
	  update_height r;
	  rl.left <- t;
	  rl.right <- r;
	  update_height rl;
	  rl
      end
  end

  (* Last situation: the tree is not unbalanced. *)
  (* Just update its height field. [t] remains the root. *)
  else begin
    t.height <- max (hl, hr) + 1;
    t
  end

val make [k, a] () : tree k a =
  Empty

val is_empty [k, a] (t : tree k a) : bool =
  match t with
  | Empty -> True
  | Node  -> False
  end

val rec add [k, a] (cmp: (k, k) -> int, consumes x: k, consumes d: a, consumes t: tree k a) : tree k a =
  match t with
  | Empty ->
      (* Here, we could possibly re-use this [Empty] node instead of
	 creating two new ones. *)
      singleton (x, d)
  | Node ->
      let c = cmp (x, t.key) in
      if c = 0 then begin
	(* The key already exists; overwrite the previous data *)
	t.value <- d;
	t
      end
      else if c < 0 then begin
	t.left <- add (cmp, x, d, t.left);
	bal t
      end
      else begin
	t.right <- add (cmp, x, d, t.right);
	bal t
      end
  end

(* It seems that the function [find] must require [duplicable a].
   Indeed, without this hypothesis, we would be forced to consume
   the argument tree [t], which does not seem reasonable. *)

val rec find [k, a] duplicable a => (cmp: (k, k) -> int, x: k, t: tree k a) : option a =
  match t with
  | Empty ->
      none
  | Node ->
      let c = cmp (x, t.key) in
      if c = 0 then some t.value
      (* It is interesting to note that we cannot write the more compact code:
	 find (cmp, x, (if c < 0 then t.left else t.right))
	 Indeed, the type-checker is unable to figure out the desired type of
	 the conditional sub-expression; it reports a resource allocation
	 conflict. In fact, if we wanted to explicitly declare this type,
	 I believe that we would need a magic wand: this sub-expression
	 produces a result [s] together with the permissions [s @ tree k a]
	 and [s @ tree k a -* t @ tree k a]. *)
      else if c < 0 then find (cmp, x, t.left)
      else find (cmp, x, t.right)
  end

(* The above [find] function requires [a] to be duplicable. Another approach
   is to parameterize [find] with a [copy] function that is able to copy an
   element of type [a]. In fact, the [copy] function need not have type [a -> a].
   Several generalizations are possible. First, we can allow [copy] to have type
   [a -> b], which means that the function is not constrained to just copy the
   data, but can use it in an arbitrary manner to produce data of type [b]. For
   this reason, the client-provided function will be called [use], rather than
   [copy]. Second, the function [use] can have type [(consumes a) -> (a, b)],
   which means that in addition to producing some output of type [b], the client
   can also request that the map be updated with a new value of type [a]
   at this key. Last, the function [use] can be allowed to have an arbitrary
   side effect at some permission [p]. This leads us to the following function,
   [find_use_update], a generalization of [find]. *)

val rec find_use_update
  [k, a, b, p :: PERM]
  (cmp: (k, k) -> int, 
   use: (consumes a | p) -> (a, b),
   x: k, t: tree k a | p) : option b =
  match t with
  | Empty ->
      none
  | Node ->
      let c = cmp (x, t.key) in
      if c = 0 then begin
	let (new_value, output) = use t.value in
	t.value <- new_value;
	some output
      end
      else if c < 0 then find_use_update (cmp, use, x, t.left)
      else find_use_update (cmp, use, x, t.right)
  end

val rec mem [k, a] (cmp: (k, k) -> int, x: k, t: tree k a) : bool =
  match t with
  | Empty ->
      False
  | Node ->
    let c = cmp (x, t.key) in
    if c = 0 then
      True
    else if c < 0 then
      mem (cmp, x, t.left)
    else
      mem (cmp, x, t.right)
  end

(* Note that [min_binding] is defined first for non-empty trees, then
   extended to empty trees. *)

val rec min_binding
  [k, a] duplicable k, duplicable a =>
  (t : Node { left: tree k a; key: k; value: a; right: tree k a; height: int })
  : (k, a) =
  match t.left with
  | Empty ->
      t.key, t.value
  | Node ->
      min_binding t.left
  end

val min_binding
  [k, a] duplicable k, duplicable a =>
  (t : tree k a)
  : option (k, a) =
  match t with
  | Empty ->
      none
  | Node ->
      some (min_binding t)
  end

(* [extract_min_binding] extracts the node that contains the minimum key.
   It returns both this node (which can be re-used) and the remaining,
   re-organized tree. By convention, instead of returning a pair, we
   return a single node, which contains the minimum key, and whose
   right child is the remaining tree. *)

val rec extract_min_binding
  [k, a]
  (consumes t : Node { left: tree k a; key: k; value: a; right: tree k a; height: int })
  :             Node { left:    Empty; key: k; value: a; right: tree k a; height: int }
  =
  match t.left with
  | Empty ->
      (* The desired node is [t], and the sub-tree [t.right] is what remains. *)
      t
  | Node ->
      (* Extract the minimum node out of the left sub-tree. *)
      let node = extract_min_binding t.left in
      (* Update in place the left sub-tree. *)
      t.left <- node.right;
      (* Perform a rotation at the root if required, and return. *)
      node.right <- bal t;
      node
  end

val merge [k, a] (consumes t1: tree k a, consumes t2: tree k a) : tree k a =
  match t1, t2 with
  | Empty, t -> t
  | t, Empty -> t
  | Node, Node ->
      (* Extract the minimum node out of [t2]... *)
      let root = extract_min_binding t2 in
      (* And re-use this node to become the new root. *)
      root.left <- t1;
      bal root
  end

(* Compared with OCaml's [remove], our [remove] function combines [find]
   and [remove]. It returns a pair of the binding that was removed and
   the new tree. *)

val rec remove [k, a] (cmp: (k, k) -> int, x: k, consumes t: tree k a)
  : (option (k, a), tree k a)
  =
  match t with
  | Empty ->
      none, t
  | Node ->
      let c = cmp (x, t.key) in
      if c = 0 then
	some (t.key, t.value),
	merge (t.left, t.right)
      else if c < 0 then begin
	let binding, left = remove (cmp, x, t.left) in
	t.left <- left;
	binding, bal t
      end
      else begin
	let binding, right = remove (cmp, x, t.right) in
	t.right <- right;
	binding, bal t
      end
  end

(* Compared with OCaml's [iter], our [iter] function is generalized
   to allow early termination. The client function, [f], is allowed
   to return a Boolean flag, which indicates whether iteration should
   continue. The function [iter] itself returns a Boolean outcome
   which indicates whether iteration was performed all the way to the
   end. *)

(* This feature implies that the type of the collection elements cannot
   be modified. Our version of [fold] (below) makes the converse choices:
   early termination is not possible, but the type of the elements can be
   changed from [a1] to [a2]. *)

(* In fact, our [iter] is exactly OCaml's [for_all]. (Except that the
   evaluation order is not the same; OCaml's [iter] guarantees that
   the keys are visited in increasing order, where OCaml's [for_all]
   does not.) Funny -- I never explicitly thought of [for_all] as a
   version of [iter] that has an early termination feature. *)

val rec iter [k, a, p :: PERM] (
  f: (k,           a | p) -> bool,
         t: tree k a | p)  : bool =
  match t with
  | Empty ->
      True
  | Node ->
      (* TEMPORARY this could be very concisely written using && *)
      if iter (f, t.left) then
	if f (t.key, t.value) then
	  iter (f, t.right)
	else False
      else False
  end

(* Our [map] is modeled after OCaml's [mapi]. One could in fact offer
   even more generality by allowing keys to be copied/translated, as
   long as the key ordering is preserved. *)

val rec map [k, a1, a2, b, p :: PERM] duplicable k => (
  f: (k, consumes d:        a1 | p) -> (b        | d @        a2),
         consumes t: tree k a1 | p)  : (tree k b | t @ tree k a2) =
  match t with
  | Empty ->
      Empty
  | Node ->
      Node {
	left = map (f, t.left);
	key = t.key;
	value = f (t.key, t.value);
	right = map (f, t.right);
	height = t.height
      }
  end

val rec fold [k, a1, a2, b, p :: PERM] (
  f: (k, consumes d:        a1, consumes accu: b | p) -> (b | d @        a2),
         consumes t: tree k a1, consumes accu: b | p)  : (b| t @ tree k a2) =
  match t with
  | Empty ->
      accu
  | Node ->
      let accu = fold (f, t.left, accu) in
      let accu = f (t.key, t.value, accu) in
      let accu = fold (f, t.right, accu) in
      accu
  end

val for_all = iter

(* [exists] could be implemented directly, but an implementation in
   terms of [for_all] is preferred, as a test of the type-checker. *)

val exists [k, a, p :: PERM] (
  f: (k,           a | p) -> bool,
         t: tree k a | p)  : bool =
  let notf (key: k, value: a | p) : bool =
    not (f (key, value))
  in
  not (for_all (notf, t))

val rec add_min_binding [k, a]
  (consumes binding: Node { left: Empty; key: k; value: a; right: unknown; height: unknown },
   consumes t: tree k a) : tree k a =
  match t with
  | Empty ->
      (* Turn [binding] into a singleton tree. *)
      binding.right <- t; (* re-use the memory block at [t], which is [Empty] *)
      binding.height <- 1;
      binding
  | Node ->
      t.left <- add_min_binding (binding, t.left);
      bal t
  end

val rec add_max_binding [k, a]
  (consumes binding: Node { left: unknown; key: k; value: a; right: Empty; height: unknown },
   consumes t: tree k a) : tree k a =
  match t with
  | Empty ->
      (* Turn [binding] into a singleton tree. *)
      binding.left <- t; (* re-use the memory block at [t], which is [Empty] *)
      binding.height <- 1;
      binding
  | Node ->
      t.right <- add_max_binding (binding, t.right);
      bal t
  end

val rec join [k, a] (consumes t: Node { left: tree k a; key: k; value: a; right: tree k a; height: int }) : tree k a =
  let left, right = t.left, t.right in
  match t.left, t.right with
  | Empty, _ ->
      add_min_binding (t, right)
  | _, Empty ->
      add_max_binding (t, left)
  | Node, Node ->
      if left.height > right.height + 2 then begin
	(* The left node becomes the root. *)
	(* The root node becomes the right child. *)
	t.left <- left.right;
	left.right <- join t;
	bal left
      end
      else if right.height > left.height + 2 then begin
	t.right <- right.left;
	right.left <- join t;
	bal right
      end
      else begin
	update_height t;
	t
      end
  end

(* Note: [concat] is just like [merge], except it uses [join] instead of [bal]. *)

val concat [k, a] (consumes t1: tree k a, consumes t2: tree k a) : tree k a =
  match t1, t2 with
  | Empty, t -> t
  | t, Empty -> t
  | Node, Node ->
      let root = extract_min_binding t2 in
      root.left <- t1;
      join root
  end

(*

    let concat_or_join t1 v d t2 =
      match d with
      | Some d -> join t1 v d t2
      | None -> concat t1 t2

    let rec split x = function
        Empty ->
          (Empty, None, Empty)
      | Node(l, v, d, r, _) ->
          let c = Ord.compare x v in
          if c = 0 then (l, Some d, r)
          else if c < 0 then
            let (ll, pres, rl) = split x l in (ll, pres, join rl v d r)
          else
            let (lr, pres, rr) = split x r in (join l v d lr, pres, rr)

    let rec merge f s1 s2 =
      match (s1, s2) with
        (Empty, Empty) -> Empty
      | (Node (l1, v1, d1, r1, h1), _) when h1 >= height s2 ->
          let (l2, d2, r2) = split v1 s2 in
          concat_or_join (merge f l1 l2) v1 (f v1 (Some d1) d2) (merge f r1 r2)
      | (_, Node (l2, v2, d2, r2, h2)) ->
          let (l1, d1, r1) = split v2 s1 in
          concat_or_join (merge f l1 l2) v2 (f v2 d1 (Some d2)) (merge f r1 r2)
      | _ ->
          assert false

    let rec filter p = function
        Empty -> Empty
      | Node(l, v, d, r, _) ->
          (* call [p] in the expected left-to-right order *)
          let l' = filter p l in
          let pvd = p v d in
          let r' = filter p r in
          if pvd then join l' v d r' else concat l' r'

    let rec partition p = function
        Empty -> (Empty, Empty)
      | Node(l, v, d, r, _) ->
          (* call [p] in the expected left-to-right order *)
          let (lt, lf) = partition p l in
          let pvd = p v d in
          let (rt, rf) = partition p r in
          if pvd
          then (join lt v d rt, concat lf rf)
          else (concat lt rt, join lf v d rf)

    type 'a enumeration = End | More of key * 'a * 'a t * 'a enumeration

    let rec cons_enum m e =
      match m with
        Empty -> e
      | Node(l, v, d, r, _) -> cons_enum l (More(v, d, r, e))

    let compare cmp m1 m2 =
      let rec compare_aux e1 e2 =
          match (e1, e2) with
          (End, End) -> 0
        | (End, _)  -> -1
        | (_, End) -> 1
        | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->
            let c = Ord.compare v1 v2 in
            if c <> 0 then c else
            let c = cmp d1 d2 in
            if c <> 0 then c else
            compare_aux (cons_enum r1 e1) (cons_enum r2 e2)
      in compare_aux (cons_enum m1 End) (cons_enum m2 End)

    let equal cmp m1 m2 =
      let rec equal_aux e1 e2 =
          match (e1, e2) with
          (End, End) -> true
        | (End, _)  -> false
        | (_, End) -> false
        | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->
            Ord.compare v1 v2 = 0 && cmp d1 d2 &&
            equal_aux (cons_enum r1 e1) (cons_enum r2 e2)
      in equal_aux (cons_enum m1 End) (cons_enum m2 End)

    let rec cardinal = function
        Empty -> 0
      | Node(l, _, _, r, _) -> cardinal l + 1 + cardinal r

    let rec bindings_aux accu = function
        Empty -> accu
      | Node(l, v, d, r, _) -> bindings_aux ((v, d) :: bindings_aux accu r) l

    let bindings s =
      bindings_aux [] s

    let choose = min_binding

*)

